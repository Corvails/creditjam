"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/complete/page",{

/***/ "(app-pages-browser)/./src/app/complete/algorithm.js":
/*!***************************************!*\
  !*** ./src/app/complete/algorithm.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst cards = __webpack_require__(/*! ./finalcreditcard.json */ \"(app-pages-browser)/./src/app/complete/finalcreditcard.json\");\n// Function to filter by credit score\nfunction filterByCreditScore(cards, creditScore) {\n    const allowedTiers = {\n        \"Poor\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Fair\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Very Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Excellent\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    };\n    let matchedCreditLevel = null;\n    let poor = false;\n    if (creditScore.includes(\"Poor\")) {\n        matchedCreditLevel = \"Poor\";\n        poor = true;\n    } else if (creditScore.includes(\"Fair\")) {\n        matchedCreditLevel = \"Fair\";\n        poor = true;\n    } else if (creditScore.includes(\"Good\")) {\n        matchedCreditLevel = \"Good\";\n    } else if (creditScore.includes(\"Very good\")) {\n        matchedCreditLevel = \"Very Good\";\n    } else if (creditScore.includes(\"Excellent\")) {\n        matchedCreditLevel = \"Excellent\";\n    }\n    // Filter cards by checking if the card's tier is allowed for the user's credit score\n    const filteredCards = cards.filter((card)=>allowedTiers[matchedCreditLevel].includes(card.Tier));\n    return {\n        filteredCards,\n        poor\n    };\n}\n// Function to apply user preferences (nuking)\nfunction applyPreferences(cards, preferences) {\n    return cards.filter((card)=>{\n        if (preferences.isStudent === \"No\" && card.Name.toLowerCase().includes(\"student\")) {\n            return false;\n        }\n        if (preferences.isBusinessOwner === \"No\" && card.Category.toLowerCase().includes(\"business\")) {\n            return false;\n        }\n        if (preferences.interestedInHotelCards === \"No\" && card.Category.toLowerCase().includes(\"hotel\")) {\n            return false;\n        }\n        if (preferences.interestedInAirlineCards === \"No\" && card.Category.toLowerCase().includes(\"airline\")) {\n            return false;\n        }\n        return true;\n    });\n}\nfunction calculateScores(cards, preferences) {\n    return cards.map((card)=>{\n        let score = +card.Score || 50;\n        // Split categories\n        const cardCategories = card.Category ? card.Category.toLowerCase().split(\"/\") : [];\n        const cardName = card.Name ? card.Name.toLowerCase() : \"\";\n        // Apply scoring rules\n        if (preferences.topCategories && preferences.topCategories.length > 0) {\n            // Check if any topCategory matches any of the card's categories\n            const matchesTopCategory = preferences.topCategories.some((category)=>cardCategories.some((cardCategory)=>cardCategory.trim() === category.toLowerCase()));\n            if (matchesTopCategory) {\n                score += 15; // Add 15 points if card's category matches any topCategory\n            }\n        }\n        if (preferences.isStudent === \"Yes\" && cardName.includes(\"student\")) score += 15;\n        if (preferences.isBusinessOwner === \"Yes\" && cardCategories.includes(\"business\")) score += 10;\n        if (preferences.inCreditCardDebt === \"Yes\" && cardCategories.includes(\"balance\")) score += 10;\n        if (preferences.interestedInHotelCards === \"Yes\" && cardCategories.includes(\"hotel\")) score += 15;\n        if (preferences.interestedInAirlineCards === \"Yes\" && cardCategories.includes(\"airline\")) score += 50;\n        if (preferences.preferredAirline) {\n            if (cardName.includes(preferences.preferredAirline.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.currentBanks && preferences.currentBanks.length > 0) {\n            preferences.currentBanks.forEach((bank)=>{\n                if (cardName.includes(bank.toLowerCase())) {\n                    score += 10;\n                }\n            });\n        }\n        return {\n            ...card,\n            score\n        }; // Return card with updated score\n    });\n}\n// Function to sort and tier cards\nfunction sortAndTierCards(cards) {\n    const tiers = {\n        tier0: [],\n        tier1: [],\n        tier2: [],\n        tier3: []\n    };\n    cards.forEach((card)=>{\n        if (card.Tier === \"0\") tiers.tier0.push(card);\n        else if (card.Tier === \"1\") tiers.tier1.push(card);\n        else if (card.Tier === \"2\") tiers.tier2.push(card);\n        else if (card.Tier === \"3\") tiers.tier3.push(card);\n    });\n    // Sort each tier by the updated score\n    for(const tier in tiers){\n        tiers[tier].sort((a, b)=>b.score - a.score);\n    }\n    return tiers;\n}\n// Function to sort by both category and tier, returning only the top card\nfunction sortByCategoryAndTier(recommendedCards, category, tier) {\n    const cardsInTier = recommendedCards[\"tier\".concat(tier)];\n    if (!cardsInTier) {\n        console.log(\"No cards found for tier: \".concat(tier));\n        return null;\n    }\n    // Filter and organize cards by category\n    const sortedByCategory = {};\n    cardsInTier.forEach((card)=>{\n        const cardCategory = card.Category.toLowerCase();\n        // Perform partial match for category\n        if (cardCategory.includes(category.toLowerCase())) {\n            if (!sortedByCategory[cardCategory]) {\n                sortedByCategory[cardCategory] = [];\n            }\n            sortedByCategory[cardCategory].push(card);\n        }\n    });\n    if (Object.keys(sortedByCategory).length === 0) {\n        console.log(\"No cards found for categories containing: \".concat(category));\n        return null;\n    }\n    let topCard = null;\n    // Find the top card by score across all matching categories\n    for(const matchedCategory in sortedByCategory){\n        const sortedCards = [\n            ...sortedByCategory[matchedCategory]\n        ].sort((a, b)=>b.score - a.score);\n        // Take the first card (highest score) if there is no topCard yet or if the current card has a higher score\n        if (!topCard || sortedCards[0].score > topCard.score) {\n            topCard = sortedCards[0];\n        }\n    }\n    if (!topCard) {\n        console.log(\"No top card found for category containing: \".concat(category, \" and tier: \").concat(tier));\n        return null;\n    }\n    return topCard;\n}\n// Main function to get recommended cards\nfunction getRecommendedCards(userPreferences) {\n    const { filteredCards, poor } = filterByCreditScore(cards, userPreferences.creditScore);\n    const adjustedCards = applyPreferences(filteredCards, userPreferences);\n    const scoredCards = calculateScores(adjustedCards, userPreferences);\n    const sortedCards = sortAndTierCards(scoredCards);\n    return {\n        sortedCards,\n        poor\n    }; // Return poor flag as well\n}\n// Function to get final recommended cards\nfunction finalCards(userInput) {\n    const { sortedCards: recommendedCards, poor } = getRecommendedCards(userInput);\n    const returnCard = [];\n    const cardCategories = userInput.topCategories.map((category)=>category.toLowerCase());\n    let index = 1;\n    if (poor) {\n        index--;\n    }\n    for(let i = 0; i < cardCategories.length; i++){\n        const category = cardCategories[i];\n        const card1 = sortByCategoryAndTier(recommendedCards, category, 0 + index);\n        const card2 = sortByCategoryAndTier(recommendedCards, category, 1 + index);\n        const card3 = sortByCategoryAndTier(recommendedCards, category, 2 + index);\n        if (card1 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card1);\n        }\n        if (card2 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card2);\n        }\n        if (card3 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card3);\n        }\n    }\n    const cardM = sortByCategoryAndTier(recommendedCards, \"Catch All\", 1);\n    if (cardM) returnCard.push(cardM);\n    if (userInput.interestedInHotelCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Hotel\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    if (userInput.interestedInAirlineCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Airline\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    return returnCard;\n}\nmodule.exports = {\n    finalCards\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcGxldGUvYWxnb3JpdGhtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQywyRkFBd0I7QUFFOUMscUNBQXFDO0FBQ3JDLFNBQVNDLG9CQUFvQkYsS0FBSyxFQUFFRyxXQUFXO0lBQzdDLE1BQU1DLGVBQWU7UUFDbkIsUUFBUTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQ3ZCLFFBQVE7WUFBQztZQUFLO1lBQUs7U0FBSTtRQUN2QixRQUFRO1lBQUM7WUFBSztZQUFLO1NBQUk7UUFDdkIsYUFBYTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQzVCLGFBQWE7WUFBQztZQUFLO1lBQUs7U0FBSTtJQUM5QjtJQUVBLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxPQUFPO0lBRVgsSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDaENGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtJQUN2QixPQUFPLElBQUlGLFlBQVlJLFFBQVEsQ0FBQyxjQUFjO1FBQzVDRixxQkFBcUI7SUFDdkIsT0FBTyxJQUFJRixZQUFZSSxRQUFRLENBQUMsY0FBYztRQUM1Q0YscUJBQXFCO0lBQ3ZCO0lBRUEscUZBQXFGO0lBQ3JGLE1BQU1HLGdCQUFnQlIsTUFBTVMsTUFBTSxDQUFDQyxDQUFBQSxPQUNqQ04sWUFBWSxDQUFDQyxtQkFBbUIsQ0FBQ0UsUUFBUSxDQUFDRyxLQUFLQyxJQUFJO0lBR3JELE9BQU87UUFBRUg7UUFBZUY7SUFBSztBQUMvQjtBQUVBLDhDQUE4QztBQUM5QyxTQUFTTSxpQkFBaUJaLEtBQUssRUFBRWEsV0FBVztJQUMxQyxPQUFPYixNQUFNUyxNQUFNLENBQUNDLENBQUFBO1FBQ2xCLElB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QUFJMUMsTUFBTTBELFdBQVd0QixJQUFJLENBQUNwQztJQUM1QixPQUNJO1FBQ0YwRCxXQUFXdEIsSUFBSSxDQUFDO0lBQ2xCO0lBRUEsT0FBT3NCO0FBQ1Q7QUFFQU8sT0FBT0MsT0FBTyxHQUFHO0lBQUVWO0FBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wbGV0ZS9hbGdvcml0aG0uanM/MWE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjYXJkcyA9IHJlcXVpcmUoXCIuL2ZpbmFsY3JlZGl0Y2FyZC5qc29uXCIpO1xyXG5cclxuLy8gRnVuY3Rpb24gdG8gZmlsdGVyIGJ5IGNyZWRpdCBzY29yZVxyXG5mdW5jdGlvbiBmaWx0ZXJCeUNyZWRpdFNjb3JlKGNhcmRzLCBjcmVkaXRTY29yZSkge1xyXG4gIGNvbnN0IGFsbG93ZWRUaWVycyA9IHtcclxuICAgIFwiUG9vclwiOiBbXCIwXCIsIFwiMVwiLCBcIjJcIl0sXHJcbiAgICBcIkZhaXJcIjogW1wiMFwiLCBcIjFcIiwgXCIyXCJdLFxyXG4gICAgXCJHb29kXCI6IFtcIjFcIiwgXCIyXCIsIFwiM1wiXSxcclxuICAgIFwiVmVyeSBHb29kXCI6IFtcIjFcIiwgXCIyXCIsIFwiM1wiXSxcclxuICAgIFwiRXhjZWxsZW50XCI6IFtcIjFcIiwgXCIyXCIsIFwiM1wiXSxcclxuICB9O1xyXG5cclxuICBsZXQgbWF0Y2hlZENyZWRpdExldmVsID0gbnVsbDtcclxuICBsZXQgcG9vciA9IGZhbHNlO1xyXG5cclxuICBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJQb29yXCIpKSB7XHJcbiAgICBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBcIlBvb3JcIjtcclxuICAgIHBvb3IgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJGYWlyXCIpKSB7XHJcbiAgICBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBcIkZhaXJcIjtcclxuICAgIHBvb3IgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJHb29kXCIpKSB7XHJcbiAgICBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBcIkdvb2RcIjtcclxuICB9IGVsc2UgaWYgKGNyZWRpdFNjb3JlLmluY2x1ZGVzKFwiVmVyeSBnb29kXCIpKSB7XHJcbiAgICBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBcIlZlcnkgR29vZFwiO1xyXG4gIH0gZWxzZSBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJFeGNlbGxlbnRcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiRXhjZWxsZW50XCI7XHJcbiAgfVxyXG5cclxuICAvLyBGaWx0ZXIgY2FyZHMgYnkgY2hlY2tpbmcgaWYgdGhlIGNhcmQncyB0aWVyIGlzIGFsbG93ZWQgZm9yIHRoZSB1c2VyJ3MgY3JlZGl0IHNjb3JlXHJcbiAgY29uc3QgZmlsdGVyZWRDYXJkcyA9IGNhcmRzLmZpbHRlcihjYXJkID0+XHJcbiAgICBhbGxvd2VkVGllcnNbbWF0Y2hlZENyZWRpdExldmVsXS5pbmNsdWRlcyhjYXJkLlRpZXIpXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHsgZmlsdGVyZWRDYXJkcywgcG9vciB9O1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBhcHBseSB1c2VyIHByZWZlcmVuY2VzIChudWtpbmcpXHJcbmZ1bmN0aW9uIGFwcGx5UHJlZmVyZW5jZXMoY2FyZHMsIHByZWZlcmVuY2VzKSB7XHJcbiAgcmV0dXJuIGNhcmRzLmZpbHRlcihjYXJkID0+IHtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pc1N0dWRlbnQgPT09IFwiTm9cIiAmJiBjYXJkLk5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInN0dWRlbnRcIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzQnVzaW5lc3NPd25lciA9PT0gXCJOb1wiICYmIGNhcmQuQ2F0ZWdvcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImJ1c2luZXNzXCIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5Ib3RlbENhcmRzID09PSBcIk5vXCIgJiYgY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiaG90ZWxcIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyA9PT0gXCJOb1wiICYmIGNhcmQuQ2F0ZWdvcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImFpcmxpbmVcIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNjb3JlcyhjYXJkcywgcHJlZmVyZW5jZXMpIHtcclxuICByZXR1cm4gY2FyZHMubWFwKGNhcmQgPT4ge1xyXG4gICAgbGV0IHNjb3JlID0gK2NhcmQuU2NvcmUgfHwgNTA7XHJcblxyXG4gICAgLy8gU3BsaXQgY2F0ZWdvcmllc1xyXG4gICAgY29uc3QgY2FyZENhdGVnb3JpZXMgPSBjYXJkLkNhdGVnb3J5ID8gY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJykgOiBbXTtcclxuICAgIGNvbnN0IGNhcmROYW1lID0gY2FyZC5OYW1lID8gY2FyZC5OYW1lLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xyXG5cclxuICAgIC8vIEFwcGx5IHNjb3JpbmcgcnVsZXNcclxuICAgIGlmIChwcmVmZXJlbmNlcy50b3BDYXRlZ29yaWVzICYmIHByZWZlcmVuY2VzLnRvcENhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBDaGVjayBpZiBhbnkgdG9wQ2F0ZWdvcnkgbWF0Y2hlcyBhbnkgb2YgdGhlIGNhcmQncyBjYXRlZ29yaWVzXHJcbiAgICAgIGNvbnN0IG1hdGNoZXNUb3BDYXRlZ29yeSA9IHByZWZlcmVuY2VzLnRvcENhdGVnb3JpZXMuc29tZShjYXRlZ29yeSA9PlxyXG4gICAgICAgIGNhcmRDYXRlZ29yaWVzLnNvbWUoY2FyZENhdGVnb3J5ID0+IGNhcmRDYXRlZ29yeS50cmltKCkgPT09IGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChtYXRjaGVzVG9wQ2F0ZWdvcnkpIHtcclxuICAgICAgICBzY29yZSArPSAxNTsgLy8gQWRkIDE1IHBvaW50cyBpZiBjYXJkJ3MgY2F0ZWdvcnkgbWF0Y2hlcyBhbnkgdG9wQ2F0ZWdvcnlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5pc1N0dWRlbnQgPT09IFwiWWVzXCIgJiYgY2FyZE5hbWUuaW5jbHVkZXMoXCJzdHVkZW50XCIpKSBzY29yZSArPSAxNTtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pc0J1c2luZXNzT3duZXIgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJidXNpbmVzc1wiKSkgc2NvcmUgKz0gMTA7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW5DcmVkaXRDYXJkRGVidCA9PT0gXCJZZXNcIiAmJiBjYXJkQ2F0ZWdvcmllcy5pbmNsdWRlcyhcImJhbGFuY2VcIikpIHNjb3JlICs9IDEwO1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmludGVyZXN0ZWRJbkhvdGVsQ2FyZHMgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJob3RlbFwiKSkgc2NvcmUgKz0gMTU7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluQWlybGluZUNhcmRzID09PSBcIlllc1wiICYmIGNhcmRDYXRlZ29yaWVzLmluY2x1ZGVzKFwiYWlybGluZVwiKSkgc2NvcmUgKz0gNTA7XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLnByZWZlcnJlZEFpcmxpbmUpIHtcclxuICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKHByZWZlcmVuY2VzLnByZWZlcnJlZEFpcmxpbmUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICBzY29yZSArPSAxMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5jdXJyZW50QmFua3MgJiYgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmZvckVhY2goYmFuayA9PiB7XHJcbiAgICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKGJhbmsudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgIHNjb3JlICs9IDEwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgLi4uY2FyZCwgc2NvcmUgfTsgLy8gUmV0dXJuIGNhcmQgd2l0aCB1cGRhdGVkIHNjb3JlXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHNvcnQgYW5kIHRpZXIgY2FyZHNcclxuZnVuY3Rpb24gc29ydEFuZFRpZXJDYXJkcyhjYXJkcykge1xyXG4gIGNvbnN0IHRpZXJzID0geyB0aWVyMDogW10sIHRpZXIxOiBbXSwgdGllcjI6IFtdLCB0aWVyMzogW10gfTtcclxuXHJcbiAgY2FyZHMuZm9yRWFjaChjYXJkID0+IHtcclxuICAgIGlmIChjYXJkLlRpZXIgPT09IFwiMFwiKSB0aWVycy50aWVyMC5wdXNoKGNhcmQpO1xyXG4gICAgZWxzZSBpZiAoY2FyZC5UaWVyID09PSBcIjFcIikgdGllcnMudGllcjEucHVzaChjYXJkKTtcclxuICAgIGVsc2UgaWYgKGNhcmQuVGllciA9PT0gXCIyXCIpIHRpZXJzLnRpZXIyLnB1c2goY2FyZCk7XHJcbiAgICBlbHNlIGlmIChjYXJkLlRpZXIgPT09IFwiM1wiKSB0aWVycy50aWVyMy5wdXNoKGNhcmQpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBTb3J0IGVhY2ggdGllciBieSB0aGUgdXBkYXRlZCBzY29yZVxyXG4gIGZvciAoY29uc3QgdGllciBpbiB0aWVycykge1xyXG4gICAgdGllcnNbdGllcl0uc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRpZXJzO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBzb3J0IGJ5IGJvdGggY2F0ZWdvcnkgYW5kIHRpZXIsIHJldHVybmluZyBvbmx5IHRoZSB0b3AgY2FyZFxyXG5mdW5jdGlvbiBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIHRpZXIpIHtcclxuICBjb25zdCBjYXJkc0luVGllciA9IHJlY29tbWVuZGVkQ2FyZHNbYHRpZXIke3RpZXJ9YF07XHJcblxyXG4gIGlmICghY2FyZHNJblRpZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGBObyBjYXJkcyBmb3VuZCBmb3IgdGllcjogJHt0aWVyfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBGaWx0ZXIgYW5kIG9yZ2FuaXplIGNhcmRzIGJ5IGNhdGVnb3J5XHJcbiAgY29uc3Qgc29ydGVkQnlDYXRlZ29yeSA9IHt9O1xyXG5cclxuICBjYXJkc0luVGllci5mb3JFYWNoKGNhcmQgPT4ge1xyXG4gICAgY29uc3QgY2FyZENhdGVnb3J5ID0gY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIFBlcmZvcm0gcGFydGlhbCBtYXRjaCBmb3IgY2F0ZWdvcnlcclxuICAgIGlmIChjYXJkQ2F0ZWdvcnkuaW5jbHVkZXMoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgaWYgKCFzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0pIHtcclxuICAgICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0ucHVzaChjYXJkKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKE9iamVjdC5rZXlzKHNvcnRlZEJ5Q2F0ZWdvcnkpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coYE5vIGNhcmRzIGZvdW5kIGZvciBjYXRlZ29yaWVzIGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGxldCB0b3BDYXJkID0gbnVsbDtcclxuXHJcbiAgLy8gRmluZCB0aGUgdG9wIGNhcmQgYnkgc2NvcmUgYWNyb3NzIGFsbCBtYXRjaGluZyBjYXRlZ29yaWVzXHJcbiAgZm9yIChjb25zdCBtYXRjaGVkQ2F0ZWdvcnkgaW4gc29ydGVkQnlDYXRlZ29yeSkge1xyXG4gICAgY29uc3Qgc29ydGVkQ2FyZHMgPSBbLi4uc29ydGVkQnlDYXRlZ29yeVttYXRjaGVkQ2F0ZWdvcnldXS5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcblxyXG4gICAgLy8gVGFrZSB0aGUgZmlyc3QgY2FyZCAoaGlnaGVzdCBzY29yZSkgaWYgdGhlcmUgaXMgbm8gdG9wQ2FyZCB5ZXQgb3IgaWYgdGhlIGN1cnJlbnQgY2FyZCBoYXMgYSBoaWdoZXIgc2NvcmVcclxuICAgIGlmICghdG9wQ2FyZCB8fCBzb3J0ZWRDYXJkc1swXS5zY29yZSA+IHRvcENhcmQuc2NvcmUpIHtcclxuICAgICAgdG9wQ2FyZCA9IHNvcnRlZENhcmRzWzBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCF0b3BDYXJkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTm8gdG9wIGNhcmQgZm91bmQgZm9yIGNhdGVnb3J5IGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9IGFuZCB0aWVyOiAke3RpZXJ9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0b3BDYXJkO1xyXG59XHJcblxyXG4vLyBNYWluIGZ1bmN0aW9uIHRvIGdldCByZWNvbW1lbmRlZCBjYXJkc1xyXG5mdW5jdGlvbiBnZXRSZWNvbW1lbmRlZENhcmRzKHVzZXJQcmVmZXJlbmNlcykge1xyXG4gIGNvbnN0IHsgZmlsdGVyZWRDYXJkcywgcG9vciB9ID0gZmlsdGVyQnlDcmVkaXRTY29yZShjYXJkcywgdXNlclByZWZlcmVuY2VzLmNyZWRpdFNjb3JlKTtcclxuICBjb25zdCBhZGp1c3RlZENhcmRzID0gYXBwbHlQcmVmZXJlbmNlcyhmaWx0ZXJlZENhcmRzLCB1c2VyUHJlZmVyZW5jZXMpO1xyXG4gIGNvbnN0IHNjb3JlZENhcmRzID0gY2FsY3VsYXRlU2NvcmVzKGFkanVzdGVkQ2FyZHMsIHVzZXJQcmVmZXJlbmNlcyk7XHJcbiAgY29uc3Qgc29ydGVkQ2FyZHMgPSBzb3J0QW5kVGllckNhcmRzKHNjb3JlZENhcmRzKTtcclxuICByZXR1cm4geyBzb3J0ZWRDYXJkcywgcG9vciB9OyAvLyBSZXR1cm4gcG9vciBmbGFnIGFzIHdlbGxcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGZpbmFsIHJlY29tbWVuZGVkIGNhcmRzXHJcbmZ1bmN0aW9uIGZpbmFsQ2FyZHModXNlcklucHV0KSB7XHJcbiAgY29uc3QgeyBzb3J0ZWRDYXJkczogcmVjb21tZW5kZWRDYXJkcywgcG9vciB9ID0gZ2V0UmVjb21tZW5kZWRDYXJkcyh1c2VySW5wdXQpO1xyXG4gIGNvbnN0IHJldHVybkNhcmQgPSBbXTtcclxuICBjb25zdCBjYXJkQ2F0ZWdvcmllcyA9IHVzZXJJbnB1dC50b3BDYXRlZ29yaWVzLm1hcChjYXRlZ29yeSA9PiBjYXRlZ29yeS50b0xvd2VyQ2FzZSgpKTtcclxuICBsZXQgaW5kZXggPSAxO1xyXG5cclxuICBpZiAocG9vcikge1xyXG4gICAgaW5kZXgtLTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZENhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gY2FyZENhdGVnb3JpZXNbaV07XHJcbiAgICBjb25zdCBjYXJkMSA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBjYXRlZ29yeSwgMCArIGluZGV4KTtcclxuICAgIGNvbnN0IGNhcmQyID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIGNhdGVnb3J5LCAxICsgaW5kZXgpO1xyXG4gICAgY29uc3QgY2FyZDMgPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIDIgKyBpbmRleCk7XHJcbiAgICBpZiAoY2FyZDEgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDIgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDMgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhcmRNID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiQ2F0Y2ggQWxsXCIsIDEpO1xyXG4gIGlmIChjYXJkTSkgcmV0dXJuQ2FyZC5wdXNoKGNhcmRNKTtcclxuXHJcbiAgaWYgKHVzZXJJbnB1dC5pbnRlcmVzdGVkSW5Ib3RlbENhcmRzID09PSBcInllc1wiKSB7XHJcbiAgICBjb25zdCBjYXJkID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiSG90ZWxcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1lbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuICBpZiAodXNlcklucHV0LmludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyA9PT0gXCJ5ZXNcIikge1xyXG4gICAgY29uc3QgY2FyZCA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBcIkFpcmxpbmVcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1cclxuICBlbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldHVybkNhcmQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBmaW5hbENhcmRzIH07Il0sIm5hbWVzIjpbImNhcmRzIiwicmVxdWlyZSIsImZpbHRlckJ5Q3JlZGl0U2NvcmUiLCJjcmVkaXRTY29yZSIsImFsbG93ZWRUaWVycyIsIm1hdGNoZWRDcmVkaXRMZXZlbCIsInBvb3IiLCJpbmNsdWRlcyIsImZpbHRlcmVkQ2FyZHMiLCJmaWx0ZXIiLCJjYXJkIiwiVGllciIsImFwcGx5UHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsImlzU3R1ZGVudCIsIk5hbWUiLCJ0b0xvd2VyQ2FzZSIsImlzQnVzaW5lc3NPd25lciIsIkNhdGVnb3J5IiwiaW50ZXJlc3RlZEluSG90ZWxDYXJkcyIsImludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyIsImNhbGN1bGF0ZVNjb3JlcyIsIm1hcCIsInNjb3JlIiwiU2NvcmUiLCJjYXJkQ2F0ZWdvcmllcyIsInNwbGl0IiwiY2FyZE5hbWUiLCJ0b3BDYXRlZ29yaWVzIiwibGVuZ3RoIiwibWF0Y2hlc1RvcENhdGVnb3J5Iiwic29tZSIsImNhdGVnb3J5IiwiY2FyZENhdGVnb3J5IiwidHJpbSIsImluQ3JlZGl0Q2FyZERlYnQiLCJwcmVmZXJyZWRBaXJsaW5lIiwiY3VycmVudEJhbmtzIiwiZm9yRWFjaCIsImJhbmsiLCJzb3J0QW5kVGllckNhcmRzIiwidGllcnMiLCJ0aWVyMCIsInRpZXIxIiwidGllcjIiLCJ0aWVyMyIsInB1c2giLCJ0aWVyIiwic29ydCIsImEiLCJiIiwic29ydEJ5Q2F0ZWdvcnlBbmRUaWVyIiwicmVjb21tZW5kZWRDYXJkcyIsImNhcmRzSW5UaWVyIiwiY29uc29sZSIsImxvZyIsInNvcnRlZEJ5Q2F0ZWdvcnkiLCJPYmplY3QiLCJrZXlzIiwidG9wQ2FyZCIsIm1hdGNoZWRDYXRlZ29yeSIsInNvcnRlZENhcmRzIiwiZ2V0UmVjb21tZW5kZWRDYXJkcyIsInVzZXJQcmVmZXJlbmNlcyIsImFkanVzdGVkQ2FyZHMiLCJzY29yZWRDYXJkcyIsImZpbmFsQ2FyZHMiLCJ1c2VySW5wdXQiLCJyZXR1cm5DYXJkIiwiaW5kZXgiLCJpIiwiY2FyZDEiLCJjYXJkMiIsImNhcmQzIiwiY2FyZE0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/complete/algorithm.js\n"));

/***/ })

});