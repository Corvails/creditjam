"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/complete/page",{

/***/ "(app-pages-browser)/./src/app/complete/algorithm.js":
/*!***************************************!*\
  !*** ./src/app/complete/algorithm.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst cards = __webpack_require__(/*! ./finalcreditcard.json */ \"(app-pages-browser)/./src/app/complete/finalcreditcard.json\");\n// Function to filter by credit score\nfunction filterByCreditScore(cards, creditScore) {\n    const allowedTiers = {\n        \"Poor\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Fair\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Very Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Excellent\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    };\n    let matchedCreditLevel = null;\n    let poor = false;\n    if (creditScore.includes(\"Poor\")) {\n        matchedCreditLevel = \"Poor\";\n        poor = true;\n    } else if (creditScore.includes(\"Fair\")) {\n        matchedCreditLevel = \"Fair\";\n        poor = true;\n    } else if (creditScore.includes(\"Good\")) {\n        matchedCreditLevel = \"Good\";\n    } else if (creditScore.includes(\"Very good\")) {\n        matchedCreditLevel = \"Very Good\";\n    } else if (creditScore.includes(\"Excellent\")) {\n        matchedCreditLevel = \"Excellent\";\n    }\n    // Filter cards by checking if the card's tier is allowed for the user's credit score\n    const filteredCards = cards.filter((card)=>allowedTiers[matchedCreditLevel].includes(card.Tier));\n    return {\n        filteredCards,\n        poor\n    };\n}\n// Function to apply user preferences (nuking)\nfunction applyPreferences(cards, preferences) {\n    return cards.filter((card)=>{\n        if (preferences.isStudent === \"No\" && card.Name.toLowerCase().includes(\"student\")) {\n            return false;\n        }\n        if (preferences.isBusinessOwner === \"No\" && card.Category.toLowerCase().includes(\"business\")) {\n            return false;\n        }\n        if (preferences.interestedInHotelCards === \"No\" && card.Category.toLowerCase().includes(\"hotel\")) {\n            return false;\n        }\n        if (preferences.interestedInAirlineCards === \"No\" && card.Category.toLowerCase().includes(\"airline\")) {\n            return false;\n        }\n        return true;\n    });\n}\nfunction calculateScores(cards, preferences) {\n    return cards.map((card)=>{\n        let score = +card.Score || 50;\n        // Split categories\n        const cardCategories = card.Category ? card.Category.toLowerCase().split(\"/\") : [];\n        const cardName = card.Name ? card.Name.toLowerCase() : \"\";\n        // Apply scoring rules\n        if (preferences.topCategories && preferences.topCategories.length > 0) {\n            // Check if any topCategory matches any of the card's categories\n            const matchesTopCategory = preferences.topCategories.some((category)=>cardCategories.some((cardCategory)=>cardCategory.trim() === category.toLowerCase()));\n            if (matchesTopCategory) {\n                score += 15; // Add 15 points if card's category matches any topCategory\n            }\n        }\n        if (preferences.isStudent === \"Yes\" && cardName.includes(\"student\")) score += 15;\n        if (preferences.isBusinessOwner === \"Yes\" && cardCategories.includes(\"business\")) score += 10;\n        if (preferences.inCreditCardDebt === \"Yes\" && cardCategories.includes(\"balance\")) score += 10;\n        if (preferences.interestedInHotelCards === \"Yes\" && cardCategories.includes(\"hotel\")) score += 10;\n        if (preferences.interestedInAirlineCards === \"Yes\" && cardCategories.includes(\"airline\")) score += 10;\n        if (preferences.preferredAirline) {\n            if (cardName.includes(preferences.preferredAirline.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.preferredHotel) {\n            if (cardName.includes(preferences.preferredHotel.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.currentBanks && preferences.currentBanks.length > 0) {\n            preferences.currentBanks.forEach((bank)=>{\n                if (cardName.includes(bank.toLowerCase())) {\n                    score += 10;\n                }\n            });\n        }\n        return {\n            ...card,\n            score\n        }; // Return card with updated score\n    });\n}\n// Function to sort and tier cards\nfunction sortAndTierCards(cards) {\n    const tiers = {\n        tier0: [],\n        tier1: [],\n        tier2: [],\n        tier3: []\n    };\n    cards.forEach((card)=>{\n        if (card.Tier === \"0\") tiers.tier0.push(card);\n        else if (card.Tier === \"1\") tiers.tier1.push(card);\n        else if (card.Tier === \"2\") tiers.tier2.push(card);\n        else if (card.Tier === \"3\") tiers.tier3.push(card);\n    });\n    // Sort each tier by the updated score\n    for(const tier in tiers){\n        tiers[tier].sort((a, b)=>b.score - a.score);\n    }\n    return tiers;\n}\n// Function to sort by both category and tier, returning only the top card\nfunction sortByCategoryAndTier(recommendedCards, category, tier) {\n    const cardsInTier = recommendedCards[\"tier\".concat(tier)];\n    if (!cardsInTier) {\n        console.log(\"No cards found for tier: \".concat(tier));\n        return null;\n    }\n    // Filter and organize cards by category\n    const sortedByCategory = {};\n    cardsInTier.forEach((card)=>{\n        const cardCategory = card.Category.toLowerCase();\n        // Perform partial match for category\n        if (cardCategory.includes(category.toLowerCase())) {\n            if (!sortedByCategory[cardCategory]) {\n                sortedByCategory[cardCategory] = [];\n            }\n            sortedByCategory[cardCategory].push(card);\n        }\n    });\n    if (Object.keys(sortedByCategory).length === 0) {\n        console.log(\"No cards found for categories containing: \".concat(category));\n        return null;\n    }\n    let topCard = null;\n    // Find the top card by score across all matching categories\n    for(const matchedCategory in sortedByCategory){\n        const sortedCards = [\n            ...sortedByCategory[matchedCategory]\n        ].sort((a, b)=>b.score - a.score);\n        // Take the first card (highest score) if there is no topCard yet or if the current card has a higher score\n        if (!topCard || sortedCards[0].score > topCard.score) {\n            topCard = sortedCards[0];\n        }\n    }\n    if (!topCard) {\n        console.log(\"No top card found for category containing: \".concat(category, \" and tier: \").concat(tier));\n        return null;\n    }\n    return topCard;\n}\n// Main function to get recommended cards\nfunction getRecommendedCards(userPreferences) {\n    const { filteredCards, poor } = filterByCreditScore(cards, userPreferences.creditScore);\n    const adjustedCards = applyPreferences(filteredCards, userPreferences);\n    const scoredCards = calculateScores(adjustedCards, userPreferences);\n    const sortedCards = sortAndTierCards(scoredCards);\n    return {\n        sortedCards,\n        poor\n    }; // Return poor flag as well\n}\n// Function to get final recommended cards\nfunction finalCards(userInput) {\n    const { sortedCards: recommendedCards, poor } = getRecommendedCards(userInput);\n    const returnCard = [];\n    const cardCategories = userInput.topCategories.map((category)=>category.toLowerCase());\n    let index = 1;\n    if (poor) {\n        index--;\n    }\n    for(let i = 0; i < cardCategories.length; i++){\n        const category = cardCategories[i];\n        const card1 = sortByCategoryAndTier(recommendedCards, category, 0 + index);\n        const card2 = sortByCategoryAndTier(recommendedCards, category, 1 + index);\n        const card3 = sortByCategoryAndTier(recommendedCards, category, 2 + index);\n        if (card1 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card1);\n        }\n        if (card2 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card2);\n        }\n        if (card3 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card3);\n        }\n    }\n    const cardM = sortByCategoryAndTier(recommendedCards, \"Catch All\", 1);\n    if (cardM) returnCard.push(cardM);\n    if (userInput.interestedInHotelCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Hotel\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    if (userInput.interestedInAirlineCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Airline\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    return returnCard;\n}\nmodule.exports = {\n    finalCards\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcGxldGUvYWxnb3JpdGhtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQywyRkFBd0I7QUFFOUMscUNBQXFDO0FBQ3JDLFNBQVNDLG9CQUFvQkYsS0FBSyxFQUFFRyxXQUFXO0lBQzdDLE1BQU1DLGVBQWU7UUFDbkIsUUFBUTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQ3ZCLFFBQVE7WUFBQztZQUFLO1lBQUs7U0FBSTtRQUN2QixRQUFRO1lBQUM7WUFBSztZQUFLO1NBQUk7UUFDdkIsYUFBYTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQzVCLGFBQWE7WUFBQztZQUFLO1lBQUs7U0FBSTtJQUM5QjtJQUVBLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxPQUFPO0lBRVgsSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDaENGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtJQUN2QixPQUFPLElBQUlGLFlBQVlJLFFBQVEsQ0FBQyxjQUFjO1FBQzVDRixxQkFBcUI7SUFDdkIsT0FBTyxJQUFJRixZQUFZSSxRQUFRLENBQUMsY0FBYztRQUM1Q0YscUJBQXFCO0lBQ3ZCO0lBRUEscUZBQXFGO0lBQ3JGLE1BQU1HLGdCQUFnQlIsTUFBTVMsTUFBTSxDQUFDQyxDQUFBQSxPQUNqQ04sWUFBWSxDQUFDQyxtQkFBbUIsQ0FBQ0UsUUFBUSxDQUFDRyxLQUFLQyxJQUFJO0lBR3JELE9BQU87UUFBRUg7UUFBZUY7SUFBSztBQUMvQjtBQUVBLDhDQUE4QztBQUM5QyxTQUFTTSxpQkFBaUJaLEtBQUssRUFBRWEsV0FBVztJQUMxQyxPQUFPYixNQUFNUyxNQUFNLENBQUNDLENBQUFBO1FBQ2xCLElB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O1FBQ0gyRCxXQUFXdEIsSUFBSSxDQUFDO0lBQ2xCO0lBQ0EsSUFBSXFCLFVBQVVoRCx3QkFBd0IsS0FBSyxPQUFPO1FBQ2hELE1BQU1WLE9BQU8wQyxzQkFBc0JDLGtCQUFrQixXQUFXO1FBQ2hFLElBQUkzQyxNQUFNMkQsV0FBV3RCLElBQUksQ0FBQ3JDO0lBQzVCLE9BQ0k7UUFDRjJELFdBQVd0QixJQUFJLENBQUM7SUFDbEI7SUFFQSxPQUFPc0I7QUFDVDtBQUVBTyxPQUFPQyxPQUFPLEdBQUc7SUFBRVY7QUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBsZXRlL2FsZ29yaXRobS5qcz8xYTcyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNhcmRzID0gcmVxdWlyZShcIi4vZmluYWxjcmVkaXRjYXJkLmpzb25cIik7XHJcblxyXG4vLyBGdW5jdGlvbiB0byBmaWx0ZXIgYnkgY3JlZGl0IHNjb3JlXHJcbmZ1bmN0aW9uIGZpbHRlckJ5Q3JlZGl0U2NvcmUoY2FyZHMsIGNyZWRpdFNjb3JlKSB7XHJcbiAgY29uc3QgYWxsb3dlZFRpZXJzID0ge1xyXG4gICAgXCJQb29yXCI6IFtcIjBcIiwgXCIxXCIsIFwiMlwiXSxcclxuICAgIFwiRmFpclwiOiBbXCIwXCIsIFwiMVwiLCBcIjJcIl0sXHJcbiAgICBcIkdvb2RcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gICAgXCJWZXJ5IEdvb2RcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gICAgXCJFeGNlbGxlbnRcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gIH07XHJcblxyXG4gIGxldCBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBudWxsO1xyXG4gIGxldCBwb29yID0gZmFsc2U7XHJcblxyXG4gIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIlBvb3JcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiUG9vclwiO1xyXG4gICAgcG9vciA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkZhaXJcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiRmFpclwiO1xyXG4gICAgcG9vciA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkdvb2RcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiR29vZFwiO1xyXG4gIH0gZWxzZSBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJWZXJ5IGdvb2RcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiVmVyeSBHb29kXCI7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkV4Y2VsbGVudFwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJFeGNlbGxlbnRcIjtcclxuICB9XHJcblxyXG4gIC8vIEZpbHRlciBjYXJkcyBieSBjaGVja2luZyBpZiB0aGUgY2FyZCdzIHRpZXIgaXMgYWxsb3dlZCBmb3IgdGhlIHVzZXIncyBjcmVkaXQgc2NvcmVcclxuICBjb25zdCBmaWx0ZXJlZENhcmRzID0gY2FyZHMuZmlsdGVyKGNhcmQgPT5cclxuICAgIGFsbG93ZWRUaWVyc1ttYXRjaGVkQ3JlZGl0TGV2ZWxdLmluY2x1ZGVzKGNhcmQuVGllcilcclxuICApO1xyXG5cclxuICByZXR1cm4geyBmaWx0ZXJlZENhcmRzLCBwb29yIH07XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGFwcGx5IHVzZXIgcHJlZmVyZW5jZXMgKG51a2luZylcclxuZnVuY3Rpb24gYXBwbHlQcmVmZXJlbmNlcyhjYXJkcywgcHJlZmVyZW5jZXMpIHtcclxuICByZXR1cm4gY2FyZHMuZmlsdGVyKGNhcmQgPT4ge1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzU3R1ZGVudCA9PT0gXCJOb1wiICYmIGNhcmQuTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic3R1ZGVudFwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaXNCdXNpbmVzc093bmVyID09PSBcIk5vXCIgJiYgY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYnVzaW5lc3NcIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmludGVyZXN0ZWRJbkhvdGVsQ2FyZHMgPT09IFwiTm9cIiAmJiBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJob3RlbFwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluQWlybGluZUNhcmRzID09PSBcIk5vXCIgJiYgY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYWlybGluZVwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVzKGNhcmRzLCBwcmVmZXJlbmNlcykge1xyXG4gIHJldHVybiBjYXJkcy5tYXAoY2FyZCA9PiB7XHJcbiAgICBsZXQgc2NvcmUgPSArY2FyZC5TY29yZSB8fCA1MDtcclxuXHJcbiAgICAvLyBTcGxpdCBjYXRlZ29yaWVzXHJcbiAgICBjb25zdCBjYXJkQ2F0ZWdvcmllcyA9IGNhcmQuQ2F0ZWdvcnkgPyBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKSA6IFtdO1xyXG4gICAgY29uc3QgY2FyZE5hbWUgPSBjYXJkLk5hbWUgPyBjYXJkLk5hbWUudG9Mb3dlckNhc2UoKSA6IFwiXCI7XHJcblxyXG4gICAgLy8gQXBwbHkgc2NvcmluZyBydWxlc1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLnRvcENhdGVnb3JpZXMgJiYgcHJlZmVyZW5jZXMudG9wQ2F0ZWdvcmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGFueSB0b3BDYXRlZ29yeSBtYXRjaGVzIGFueSBvZiB0aGUgY2FyZCdzIGNhdGVnb3JpZXNcclxuICAgICAgY29uc3QgbWF0Y2hlc1RvcENhdGVnb3J5ID0gcHJlZmVyZW5jZXMudG9wQ2F0ZWdvcmllcy5zb21lKGNhdGVnb3J5ID0+XHJcbiAgICAgICAgY2FyZENhdGVnb3JpZXMuc29tZShjYXJkQ2F0ZWdvcnkgPT4gY2FyZENhdGVnb3J5LnRyaW0oKSA9PT0gY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSlcclxuICAgICAgKTtcclxuICAgICAgaWYgKG1hdGNoZXNUb3BDYXRlZ29yeSkge1xyXG4gICAgICAgIHNjb3JlICs9IDE1OyAvLyBBZGQgMTUgcG9pbnRzIGlmIGNhcmQncyBjYXRlZ29yeSBtYXRjaGVzIGFueSB0b3BDYXRlZ29yeVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzU3R1ZGVudCA9PT0gXCJZZXNcIiAmJiBjYXJkTmFtZS5pbmNsdWRlcyhcInN0dWRlbnRcIikpIHNjb3JlICs9IDE1O1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzQnVzaW5lc3NPd25lciA9PT0gXCJZZXNcIiAmJiBjYXJkQ2F0ZWdvcmllcy5pbmNsdWRlcyhcImJ1c2luZXNzXCIpKSBzY29yZSArPSAxMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbkNyZWRpdENhcmREZWJ0ID09PSBcIlllc1wiICYmIGNhcmRDYXRlZ29yaWVzLmluY2x1ZGVzKFwiYmFsYW5jZVwiKSkgc2NvcmUgKz0gMTA7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluSG90ZWxDYXJkcyA9PT0gXCJZZXNcIiAmJiBjYXJkQ2F0ZWdvcmllcy5pbmNsdWRlcyhcImhvdGVsXCIpKSBzY29yZSArPSAxMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5BaXJsaW5lQ2FyZHMgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJhaXJsaW5lXCIpKSBzY29yZSArPSAxMDtcclxuXHJcbiAgICBpZiAocHJlZmVyZW5jZXMucHJlZmVycmVkQWlybGluZSkge1xyXG4gICAgICBpZiAoY2FyZE5hbWUuaW5jbHVkZXMocHJlZmVyZW5jZXMucHJlZmVycmVkQWlybGluZS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgIHNjb3JlICs9IDEwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLnByZWZlcnJlZEhvdGVsKSB7XHJcbiAgICAgIGlmIChjYXJkTmFtZS5pbmNsdWRlcyhwcmVmZXJlbmNlcy5wcmVmZXJyZWRIb3RlbC50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgIHNjb3JlICs9IDEwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmN1cnJlbnRCYW5rcyAmJiBwcmVmZXJlbmNlcy5jdXJyZW50QmFua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICBwcmVmZXJlbmNlcy5jdXJyZW50QmFua3MuZm9yRWFjaChiYW5rID0+IHtcclxuICAgICAgICBpZiAoY2FyZE5hbWUuaW5jbHVkZXMoYmFuay50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgc2NvcmUgKz0gMTA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyAuLi5jYXJkLCBzY29yZSB9OyAvLyBSZXR1cm4gY2FyZCB3aXRoIHVwZGF0ZWQgc2NvcmVcclxuICB9KTtcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gc29ydCBhbmQgdGllciBjYXJkc1xyXG5mdW5jdGlvbiBzb3J0QW5kVGllckNhcmRzKGNhcmRzKSB7XHJcbiAgY29uc3QgdGllcnMgPSB7IHRpZXIwOiBbXSwgdGllcjE6IFtdLCB0aWVyMjogW10sIHRpZXIzOiBbXSB9O1xyXG5cclxuICBjYXJkcy5mb3JFYWNoKGNhcmQgPT4ge1xyXG4gICAgaWYgKGNhcmQuVGllciA9PT0gXCIwXCIpIHRpZXJzLnRpZXIwLnB1c2goY2FyZCk7XHJcbiAgICBlbHNlIGlmIChjYXJkLlRpZXIgPT09IFwiMVwiKSB0aWVycy50aWVyMS5wdXNoKGNhcmQpO1xyXG4gICAgZWxzZSBpZiAoY2FyZC5UaWVyID09PSBcIjJcIikgdGllcnMudGllcjIucHVzaChjYXJkKTtcclxuICAgIGVsc2UgaWYgKGNhcmQuVGllciA9PT0gXCIzXCIpIHRpZXJzLnRpZXIzLnB1c2goY2FyZCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFNvcnQgZWFjaCB0aWVyIGJ5IHRoZSB1cGRhdGVkIHNjb3JlXHJcbiAgZm9yIChjb25zdCB0aWVyIGluIHRpZXJzKSB7XHJcbiAgICB0aWVyc1t0aWVyXS5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGllcnM7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHNvcnQgYnkgYm90aCBjYXRlZ29yeSBhbmQgdGllciwgcmV0dXJuaW5nIG9ubHkgdGhlIHRvcCBjYXJkXHJcbmZ1bmN0aW9uIHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBjYXRlZ29yeSwgdGllcikge1xyXG4gIGNvbnN0IGNhcmRzSW5UaWVyID0gcmVjb21tZW5kZWRDYXJkc1tgdGllciR7dGllcn1gXTtcclxuXHJcbiAgaWYgKCFjYXJkc0luVGllcikge1xyXG4gICAgY29uc29sZS5sb2coYE5vIGNhcmRzIGZvdW5kIGZvciB0aWVyOiAke3RpZXJ9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEZpbHRlciBhbmQgb3JnYW5pemUgY2FyZHMgYnkgY2F0ZWdvcnlcclxuICBjb25zdCBzb3J0ZWRCeUNhdGVnb3J5ID0ge307XHJcblxyXG4gIGNhcmRzSW5UaWVyLmZvckVhY2goY2FyZCA9PiB7XHJcbiAgICBjb25zdCBjYXJkQ2F0ZWdvcnkgPSBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gUGVyZm9ybSBwYXJ0aWFsIG1hdGNoIGZvciBjYXRlZ29yeVxyXG4gICAgaWYgKGNhcmRDYXRlZ29yeS5pbmNsdWRlcyhjYXRlZ29yeS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICBpZiAoIXNvcnRlZEJ5Q2F0ZWdvcnlbY2FyZENhdGVnb3J5XSkge1xyXG4gICAgICAgIHNvcnRlZEJ5Q2F0ZWdvcnlbY2FyZENhdGVnb3J5XSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHNvcnRlZEJ5Q2F0ZWdvcnlbY2FyZENhdGVnb3J5XS5wdXNoKGNhcmQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoT2JqZWN0LmtleXMoc29ydGVkQnlDYXRlZ29yeSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTm8gY2FyZHMgZm91bmQgZm9yIGNhdGVnb3JpZXMgY29udGFpbmluZzogJHtjYXRlZ29yeX1gKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgbGV0IHRvcENhcmQgPSBudWxsO1xyXG5cclxuICAvLyBGaW5kIHRoZSB0b3AgY2FyZCBieSBzY29yZSBhY3Jvc3MgYWxsIG1hdGNoaW5nIGNhdGVnb3JpZXNcclxuICBmb3IgKGNvbnN0IG1hdGNoZWRDYXRlZ29yeSBpbiBzb3J0ZWRCeUNhdGVnb3J5KSB7XHJcbiAgICBjb25zdCBzb3J0ZWRDYXJkcyA9IFsuLi5zb3J0ZWRCeUNhdGVnb3J5W21hdGNoZWRDYXRlZ29yeV1dLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcclxuXHJcbiAgICAvLyBUYWtlIHRoZSBmaXJzdCBjYXJkIChoaWdoZXN0IHNjb3JlKSBpZiB0aGVyZSBpcyBubyB0b3BDYXJkIHlldCBvciBpZiB0aGUgY3VycmVudCBjYXJkIGhhcyBhIGhpZ2hlciBzY29yZVxyXG4gICAgaWYgKCF0b3BDYXJkIHx8IHNvcnRlZENhcmRzWzBdLnNjb3JlID4gdG9wQ2FyZC5zY29yZSkge1xyXG4gICAgICB0b3BDYXJkID0gc29ydGVkQ2FyZHNbMF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXRvcENhcmQpIHtcclxuICAgIGNvbnNvbGUubG9nKGBObyB0b3AgY2FyZCBmb3VuZCBmb3IgY2F0ZWdvcnkgY29udGFpbmluZzogJHtjYXRlZ29yeX0gYW5kIHRpZXI6ICR7dGllcn1gKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRvcENhcmQ7XHJcbn1cclxuXHJcbi8vIE1haW4gZnVuY3Rpb24gdG8gZ2V0IHJlY29tbWVuZGVkIGNhcmRzXHJcbmZ1bmN0aW9uIGdldFJlY29tbWVuZGVkQ2FyZHModXNlclByZWZlcmVuY2VzKSB7XHJcbiAgY29uc3QgeyBmaWx0ZXJlZENhcmRzLCBwb29yIH0gPSBmaWx0ZXJCeUNyZWRpdFNjb3JlKGNhcmRzLCB1c2VyUHJlZmVyZW5jZXMuY3JlZGl0U2NvcmUpO1xyXG4gIGNvbnN0IGFkanVzdGVkQ2FyZHMgPSBhcHBseVByZWZlcmVuY2VzKGZpbHRlcmVkQ2FyZHMsIHVzZXJQcmVmZXJlbmNlcyk7XHJcbiAgY29uc3Qgc2NvcmVkQ2FyZHMgPSBjYWxjdWxhdGVTY29yZXMoYWRqdXN0ZWRDYXJkcywgdXNlclByZWZlcmVuY2VzKTtcclxuICBjb25zdCBzb3J0ZWRDYXJkcyA9IHNvcnRBbmRUaWVyQ2FyZHMoc2NvcmVkQ2FyZHMpO1xyXG4gIHJldHVybiB7IHNvcnRlZENhcmRzLCBwb29yIH07IC8vIFJldHVybiBwb29yIGZsYWcgYXMgd2VsbFxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBnZXQgZmluYWwgcmVjb21tZW5kZWQgY2FyZHNcclxuZnVuY3Rpb24gZmluYWxDYXJkcyh1c2VySW5wdXQpIHtcclxuICBjb25zdCB7IHNvcnRlZENhcmRzOiByZWNvbW1lbmRlZENhcmRzLCBwb29yIH0gPSBnZXRSZWNvbW1lbmRlZENhcmRzKHVzZXJJbnB1dCk7XHJcbiAgY29uc3QgcmV0dXJuQ2FyZCA9IFtdO1xyXG4gIGNvbnN0IGNhcmRDYXRlZ29yaWVzID0gdXNlcklucHV0LnRvcENhdGVnb3JpZXMubWFwKGNhdGVnb3J5ID0+IGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkpO1xyXG4gIGxldCBpbmRleCA9IDE7XHJcblxyXG4gIGlmIChwb29yKSB7XHJcbiAgICBpbmRleC0tO1xyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJkQ2F0ZWdvcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgY2F0ZWdvcnkgPSBjYXJkQ2F0ZWdvcmllc1tpXTtcclxuICAgIGNvbnN0IGNhcmQxID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIGNhdGVnb3J5LCAwICsgaW5kZXgpO1xyXG4gICAgY29uc3QgY2FyZDIgPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIDEgKyBpbmRleCk7XHJcbiAgICBjb25zdCBjYXJkMyA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBjYXRlZ29yeSwgMiArIGluZGV4KTtcclxuICAgIGlmIChjYXJkMSA9PT0gbnVsbCl7XHJcbiAgICAgIHJldHVybkNhcmQucHVzaChcIk4vQVwiKTtcclxuICAgIH1lbHNle1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goY2FyZDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYXJkMiA9PT0gbnVsbCl7XHJcbiAgICAgIHJldHVybkNhcmQucHVzaChcIk4vQVwiKTtcclxuICAgIH1lbHNle1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goY2FyZDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYXJkMyA9PT0gbnVsbCl7XHJcbiAgICAgIHJldHVybkNhcmQucHVzaChcIk4vQVwiKTtcclxuICAgIH1lbHNle1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goY2FyZDMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FyZE0gPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgXCJDYXRjaCBBbGxcIiwgMSk7XHJcbiAgaWYgKGNhcmRNKSByZXR1cm5DYXJkLnB1c2goY2FyZE0pO1xyXG5cclxuICBpZiAodXNlcklucHV0LmludGVyZXN0ZWRJbkhvdGVsQ2FyZHMgPT09IFwieWVzXCIpIHtcclxuICAgIGNvbnN0IGNhcmQgPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgXCJIb3RlbFwiLCAxKTtcclxuICAgIGlmIChjYXJkKSByZXR1cm5DYXJkLnB1c2goY2FyZCk7XHJcbiAgfWVsc2V7XHJcbiAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgfVxyXG4gIGlmICh1c2VySW5wdXQuaW50ZXJlc3RlZEluQWlybGluZUNhcmRzID09PSBcInllc1wiKSB7XHJcbiAgICBjb25zdCBjYXJkID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiQWlybGluZVwiLCAxKTtcclxuICAgIGlmIChjYXJkKSByZXR1cm5DYXJkLnB1c2goY2FyZCk7XHJcbiAgfVxyXG4gIGVsc2V7XHJcbiAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0dXJuQ2FyZDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IGZpbmFsQ2FyZHMgfTsiXSwibmFtZXMiOlsiY2FyZHMiLCJyZXF1aXJlIiwiZmlsdGVyQnlDcmVkaXRTY29yZSIsImNyZWRpdFNjb3JlIiwiYWxsb3dlZFRpZXJzIiwibWF0Y2hlZENyZWRpdExldmVsIiwicG9vciIsImluY2x1ZGVzIiwiZmlsdGVyZWRDYXJkcyIsImZpbHRlciIsImNhcmQiLCJUaWVyIiwiYXBwbHlQcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwiaXNTdHVkZW50IiwiTmFtZSIsInRvTG93ZXJDYXNlIiwiaXNCdXNpbmVzc093bmVyIiwiQ2F0ZWdvcnkiLCJpbnRlcmVzdGVkSW5Ib3RlbENhcmRzIiwiaW50ZXJlc3RlZEluQWlybGluZUNhcmRzIiwiY2FsY3VsYXRlU2NvcmVzIiwibWFwIiwic2NvcmUiLCJTY29yZSIsImNhcmRDYXRlZ29yaWVzIiwic3BsaXQiLCJjYXJkTmFtZSIsInRvcENhdGVnb3JpZXMiLCJsZW5ndGgiLCJtYXRjaGVzVG9wQ2F0ZWdvcnkiLCJzb21lIiwiY2F0ZWdvcnkiLCJjYXJkQ2F0ZWdvcnkiLCJ0cmltIiwiaW5DcmVkaXRDYXJkRGVidCIsInByZWZlcnJlZEFpcmxpbmUiLCJwcmVmZXJyZWRIb3RlbCIsImN1cnJlbnRCYW5rcyIsImZvckVhY2giLCJiYW5rIiwic29ydEFuZFRpZXJDYXJkcyIsInRpZXJzIiwidGllcjAiLCJ0aWVyMSIsInRpZXIyIiwidGllcjMiLCJwdXNoIiwidGllciIsInNvcnQiLCJhIiwiYiIsInNvcnRCeUNhdGVnb3J5QW5kVGllciIsInJlY29tbWVuZGVkQ2FyZHMiLCJjYXJkc0luVGllciIsImNvbnNvbGUiLCJsb2ciLCJzb3J0ZWRCeUNhdGVnb3J5IiwiT2JqZWN0Iiwia2V5cyIsInRvcENhcmQiLCJtYXRjaGVkQ2F0ZWdvcnkiLCJzb3J0ZWRDYXJkcyIsImdldFJlY29tbWVuZGVkQ2FyZHMiLCJ1c2VyUHJlZmVyZW5jZXMiLCJhZGp1c3RlZENhcmRzIiwic2NvcmVkQ2FyZHMiLCJmaW5hbENhcmRzIiwidXNlcklucHV0IiwicmV0dXJuQ2FyZCIsImluZGV4IiwiaSIsImNhcmQxIiwiY2FyZDIiLCJjYXJkMyIsImNhcmRNIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/complete/algorithm.js\n"));

/***/ })

});