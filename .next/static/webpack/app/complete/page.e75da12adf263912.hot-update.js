"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/complete/page",{

/***/ "(app-pages-browser)/./src/app/complete/algorithm.js":
/*!***************************************!*\
  !*** ./src/app/complete/algorithm.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst cards = __webpack_require__(/*! ./finalcreditcard.json */ \"(app-pages-browser)/./src/app/complete/finalcreditcard.json\");\n// Function to filter by credit score\nfunction filterByCreditScore(cards, creditScore) {\n    const allowedTiers = {\n        \"Poor\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Fair\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Very Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Excellent\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    };\n    let matchedCreditLevel = null;\n    let poor = false;\n    if (creditScore.includes(\"Poor\")) {\n        matchedCreditLevel = \"Poor\";\n        poor = true;\n    } else if (creditScore.includes(\"Fair\")) {\n        matchedCreditLevel = \"Fair\";\n        poor = true;\n    } else if (creditScore.includes(\"Good\")) {\n        matchedCreditLevel = \"Good\";\n    } else if (creditScore.includes(\"Very good\")) {\n        matchedCreditLevel = \"Very Good\";\n    } else if (creditScore.includes(\"Excellent\")) {\n        matchedCreditLevel = \"Excellent\";\n    }\n    // Filter cards by checking if the card's tier is allowed for the user's credit score\n    const filteredCards = cards.filter((card)=>allowedTiers[matchedCreditLevel].includes(card.Tier));\n    return {\n        filteredCards,\n        poor\n    };\n}\n// Function to apply user preferences (nuking)\nfunction applyPreferences(cards, preferences) {\n    return cards.filter((card)=>{\n        if (preferences.isStudent === \"No\" && card.Name.toLowerCase().includes(\"student\")) {\n            return false;\n        }\n        if (preferences.isBusinessOwner === \"No\" && card.Category.toLowerCase().includes(\"business\")) {\n            return false;\n        }\n        if (preferences.interestedInHotelCards === \"No\" && card.Category.toLowerCase().includes(\"hotel\")) {\n            return false;\n        }\n        if (preferences.interestedInAirlineCards === \"No\" && card.Category.toLowerCase().includes(\"airline\")) {\n            return false;\n        }\n        return true;\n    });\n}\nfunction calculateScores(cards, preferences) {\n    return cards.map((card)=>{\n        let score = +card.Score || 50;\n        // Split categories\n        const cardCategories = card.Category ? card.Category.toLowerCase().split(\"/\") : [];\n        const cardName = card.Name ? card.Name.toLowerCase() : \"\";\n        // Apply scoring rules\n        if (preferences.topCategories && preferences.topCategories.length > 0) {\n            // Check if any topCategory matches any of the card's categories\n            const matchesTopCategory = preferences.topCategories.some((category)=>cardCategories.some((cardCategory)=>cardCategory.trim() === category.toLowerCase()));\n            if (matchesTopCategory) {\n                score += 15; // Add 15 points if card's category matches any topCategory\n            }\n        }\n        if (preferences.isStudent === \"Yes\" && cardName.includes(\"student\")) score += 15;\n        if (preferences.isBusinessOwner === \"Yes\" && cardCategories.includes(\"business\")) score += 10;\n        if (preferences.inCreditCardDebt === \"Yes\" && cardCategories.includes(\"balance\")) score += 10;\n        if (preferences.interestedInHotelCards === \"Yes\" && cardCategories.includes(\"hotel\")) score += 10;\n        if (preferences.interestedInAirlineCards === \"Yes\" && cardCategories.includes(\"airline\")) score += 10;\n        if (preferences.preferredAirline) {\n            if (cardName.includes(preferences.preferredAirline.toLowerCase())) {\n                score += 500;\n            }\n        }\n        if (preferences.preferredHotel) {\n            if (cardName.includes(preferences.preferredHotel.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.currentBanks && preferences.currentBanks.length > 0) {\n            preferences.currentBanks.forEach((bank)=>{\n                if (cardName.includes(bank.toLowerCase())) {\n                    score += 10;\n                }\n            });\n        }\n        return {\n            ...card,\n            score\n        }; // Return card with updated score\n    });\n}\n// Function to sort and tier cards\nfunction sortAndTierCards(cards) {\n    const tiers = {\n        tier0: [],\n        tier1: [],\n        tier2: [],\n        tier3: []\n    };\n    cards.forEach((card)=>{\n        if (card.Tier === \"0\") tiers.tier0.push(card);\n        else if (card.Tier === \"1\") tiers.tier1.push(card);\n        else if (card.Tier === \"2\") tiers.tier2.push(card);\n        else if (card.Tier === \"3\") tiers.tier3.push(card);\n    });\n    // Sort each tier by the updated score\n    for(const tier in tiers){\n        tiers[tier].sort((a, b)=>b.score - a.score);\n    }\n    return tiers;\n}\n// Function to sort by both category and tier, returning only the top card\nfunction sortByCategoryAndTier(recommendedCards, category, tier) {\n    const cardsInTier = recommendedCards[\"tier\".concat(tier)];\n    if (!cardsInTier) {\n        console.log(\"No cards found for tier: \".concat(tier));\n        return null;\n    }\n    // Filter and organize cards by category\n    const sortedByCategory = {};\n    cardsInTier.forEach((card)=>{\n        const cardCategory = card.Category.toLowerCase();\n        // Perform partial match for category\n        if (cardCategory.includes(category.toLowerCase())) {\n            if (!sortedByCategory[cardCategory]) {\n                sortedByCategory[cardCategory] = [];\n            }\n            sortedByCategory[cardCategory].push(card);\n        }\n    });\n    if (Object.keys(sortedByCategory).length === 0) {\n        console.log(\"No cards found for categories containing: \".concat(category));\n        return null;\n    }\n    let topCard = null;\n    // Find the top card by score across all matching categories\n    for(const matchedCategory in sortedByCategory){\n        const sortedCards = [\n            ...sortedByCategory[matchedCategory]\n        ].sort((a, b)=>b.score - a.score);\n        // Take the first card (highest score) if there is no topCard yet or if the current card has a higher score\n        if (!topCard || sortedCards[0].score > topCard.score) {\n            topCard = sortedCards[0];\n        }\n    }\n    if (!topCard) {\n        console.log(\"No top card found for category containing: \".concat(category, \" and tier: \").concat(tier));\n        return null;\n    }\n    return topCard;\n}\n// Main function to get recommended cards\nfunction getRecommendedCards(userPreferences) {\n    const { filteredCards, poor } = filterByCreditScore(cards, userPreferences.creditScore);\n    const adjustedCards = applyPreferences(filteredCards, userPreferences);\n    const scoredCards = calculateScores(adjustedCards, userPreferences);\n    const sortedCards = sortAndTierCards(scoredCards);\n    return {\n        sortedCards,\n        poor\n    }; // Return poor flag as well\n}\n// Function to get final recommended cards\nfunction finalCards(userInput) {\n    const { sortedCards: recommendedCards, poor } = getRecommendedCards(userInput);\n    const returnCard = [];\n    const cardCategories = userInput.topCategories.map((category)=>category.toLowerCase());\n    let index = 1;\n    if (poor) {\n        index--;\n    }\n    for(let i = 0; i < cardCategories.length; i++){\n        const category = cardCategories[i];\n        const card1 = sortByCategoryAndTier(recommendedCards, category, 0 + index);\n        const card2 = sortByCategoryAndTier(recommendedCards, category, 1 + index);\n        const card3 = sortByCategoryAndTier(recommendedCards, category, 2 + index);\n        if (card1 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card1);\n        }\n        if (card2 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card2);\n        }\n        if (card3 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card3);\n        }\n    }\n    const cardM = sortByCategoryAndTier(recommendedCards, \"Catch All\", 1);\n    if (cardM) returnCard.push(cardM);\n    if (userInput.interestedInHotelCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Hotel\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    if (userInput.interestedInAirlineCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Airline\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    return returnCard;\n}\nmodule.exports = {\n    finalCards\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcGxldGUvYWxnb3JpdGhtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQywyRkFBd0I7QUFFOUMscUNBQXFDO0FBQ3JDLFNBQVNDLG9CQUFvQkYsS0FBSyxFQUFFRyxXQUFXO0lBQzdDLE1BQU1DLGVBQWU7UUFDbkIsUUFBUTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQ3ZCLFFBQVE7WUFBQztZQUFLO1lBQUs7U0FBSTtRQUN2QixRQUFRO1lBQUM7WUFBSztZQUFLO1NBQUk7UUFDdkIsYUFBYTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQzVCLGFBQWE7WUFBQztZQUFLO1lBQUs7U0FBSTtJQUM5QjtJQUVBLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxPQUFPO0lBRVgsSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDaENGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtJQUN2QixPQUFPLElBQUlGLFlBQVlJLFFBQVEsQ0FBQyxjQUFjO1FBQzVDRixxQkFBcUI7SUFDdkIsT0FBTyxJQUFJRixZQUFZSSxRQUFRLENBQUMsY0FBYztRQUM1Q0YscUJBQXFCO0lBQ3ZCO0lBRUEscUZBQXFGO0lBQ3JGLE1BQU1HLGdCQUFnQlIsTUFBTVMsTUFBTSxDQUFDQyxDQUFBQSxPQUNqQ04sWUFBWSxDQUFDQyxtQkFBbUIsQ0FBQ0UsUUFBUSxDQUFDRyxLQUFLQyxJQUFJO0lBR3JELE9BQU87UUFBRUg7UUFBZUY7SUFBSztBQUMvQjtBQUVBLDhDQUE4QztBQUM5QyxTQUFTTSxpQkFBaUJaLEtBQUssRUFBRWEsV0FBVztJQUMxQyxPQUFPYixNQUFNUyxNQUFNLENBQUNDLENBQUFBO1FBQ2xCLElB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O1FBQ0gyRCxXQUFXdEIsSUFBSSxDQUFDO0lBQ2xCO0lBQ0EsSUFBSXFCLFVBQVVoRCx3QkFBd0IsS0FBSyxPQUFPO1FBQ2hELE1BQU1WLE9BQU8wQyxzQkFBc0JDLGtCQUFrQixXQUFXO1FBQ2hFLElBQUkzQyxNQUFNMkQsV0FBV3RCLElBQUksQ0FBQ3JDO0lBQzVCLE9BQ0k7UUFDRjJELFdBQVd0QixJQUFJLENBQUM7SUFDbEI7SUFFQSxPQUFPc0I7QUFDVDtBQUVBTyxPQUFPQyxPQUFPLEdBQUc7SUFBRVY7QUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBsZXRlL2FsZ29yaXRobS5qcz8xYTcyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNhcmRzID0gcmVxdWlyZShcIi4vZmluYWxjcmVkaXRjYXJkLmpzb25cIik7XHJcblxyXG4vLyBGdW5jdGlvbiB0byBmaWx0ZXIgYnkgY3JlZGl0IHNjb3JlXHJcbmZ1bmN0aW9uIGZpbHRlckJ5Q3JlZGl0U2NvcmUoY2FyZHMsIGNyZWRpdFNjb3JlKSB7XHJcbiAgY29uc3QgYWxsb3dlZFRpZXJzID0ge1xyXG4gICAgXCJQb29yXCI6IFtcIjBcIiwgXCIxXCIsIFwiMlwiXSxcclxuICAgIFwiRmFpclwiOiBbXCIwXCIsIFwiMVwiLCBcIjJcIl0sXHJcbiAgICBcIkdvb2RcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gICAgXCJWZXJ5IEdvb2RcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gICAgXCJFeGNlbGxlbnRcIjogW1wiMVwiLCBcIjJcIiwgXCIzXCJdLFxyXG4gIH07XHJcblxyXG4gIGxldCBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBudWxsO1xyXG4gIGxldCBwb29yID0gZmFsc2U7XHJcblxyXG4gIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIlBvb3JcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiUG9vclwiO1xyXG4gICAgcG9vciA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkZhaXJcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiRmFpclwiO1xyXG4gICAgcG9vciA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkdvb2RcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiR29vZFwiO1xyXG4gIH0gZWxzZSBpZiAoY3JlZGl0U2NvcmUuaW5jbHVkZXMoXCJWZXJ5IGdvb2RcIikpIHtcclxuICAgIG1hdGNoZWRDcmVkaXRMZXZlbCA9IFwiVmVyeSBHb29kXCI7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIkV4Y2VsbGVudFwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJFeGNlbGxlbnRcIjtcclxuICB9XHJcblxyXG4gIC8vIEZpbHRlciBjYXJkcyBieSBjaGVja2luZyBpZiB0aGUgY2FyZCdzIHRpZXIgaXMgYWxsb3dlZCBmb3IgdGhlIHVzZXIncyBjcmVkaXQgc2NvcmVcclxuICBjb25zdCBmaWx0ZXJlZENhcmRzID0gY2FyZHMuZmlsdGVyKGNhcmQgPT5cclxuICAgIGFsbG93ZWRUaWVyc1ttYXRjaGVkQ3JlZGl0TGV2ZWxdLmluY2x1ZGVzKGNhcmQuVGllcilcclxuICApO1xyXG5cclxuICByZXR1cm4geyBmaWx0ZXJlZENhcmRzLCBwb29yIH07XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGFwcGx5IHVzZXIgcHJlZmVyZW5jZXMgKG51a2luZylcclxuZnVuY3Rpb24gYXBwbHlQcmVmZXJlbmNlcyhjYXJkcywgcHJlZmVyZW5jZXMpIHtcclxuICByZXR1cm4gY2FyZHMuZmlsdGVyKGNhcmQgPT4ge1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzU3R1ZGVudCA9PT0gXCJOb1wiICYmIGNhcmQuTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic3R1ZGVudFwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaXNCdXNpbmVzc093bmVyID09PSBcIk5vXCIgJiYgY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYnVzaW5lc3NcIikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmludGVyZXN0ZWRJbkhvdGVsQ2FyZHMgPT09IFwiTm9cIiAmJiBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJob3RlbFwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluQWlybGluZUNhcmRzID09PSBcIk5vXCIgJiYgY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYWlybGluZVwiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVzKGNhcmRzLCBwcmVmZXJlbmNlcykge1xyXG4gIHJldHVybiBjYXJkcy5tYXAoY2FyZCA9PiB7XHJcbiAgICBsZXQgc2NvcmUgPSArY2FyZC5TY29yZSB8fCA1MDtcclxuXHJcbiAgICAvLyBTcGxpdCBjYXRlZ29yaWVzXHJcbiAgICBjb25zdCBjYXJkQ2F0ZWdvcmllcyA9IGNhcmQuQ2F0ZWdvcnkgPyBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKSA6IFtdO1xyXG4gICAgY29uc3QgY2FyZE5hbWUgPSBjYXJkLk5hbWUgPyBjYXJkLk5hbWUudG9Mb3dlckNhc2UoKSA6IFwiXCI7XHJcblxyXG4gICAgLy8gQXBwbHkgc2NvcmluZyBydWxlc1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLnRvcENhdGVnb3JpZXMgJiYgcHJlZmVyZW5jZXMudG9wQ2F0ZWdvcmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGFueSB0b3BDYXRlZ29yeSBtYXRjaGVzIGFueSBvZiB0aGUgY2FyZCdzIGNhdGVnb3JpZXNcclxuICAgICAgY29uc3QgbWF0Y2hlc1RvcENhdGVnb3J5ID0gcHJlZmVyZW5jZXMudG9wQ2F0ZWdvcmllcy5zb21lKGNhdGVnb3J5ID0+XHJcbiAgICAgICAgY2FyZENhdGVnb3JpZXMuc29tZShjYXJkQ2F0ZWdvcnkgPT4gY2FyZENhdGVnb3J5LnRyaW0oKSA9PT0gY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSlcclxuICAgICAgKTtcclxuICAgICAgaWYgKG1hdGNoZXNUb3BDYXRlZ29yeSkge1xyXG4gICAgICAgIHNjb3JlICs9IDE1OyAvLyBBZGQgMTUgcG9pbnRzIGlmIGNhcmQncyBjYXRlZ29yeSBtYXRjaGVzIGFueSB0b3BDYXRlZ29yeVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzU3R1ZGVudCA9PT0gXCJZZXNcIiAmJiBjYXJkTmFtZS5pbmNsdWRlcyhcInN0dWRlbnRcIikpIHNjb3JlICs9IDE1O1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmlzQnVzaW5lc3NPd25lciA9PT0gXCJZZXNcIiAmJiBjYXJkQ2F0ZWdvcmllcy5pbmNsdWRlcyhcImJ1c2luZXNzXCIpKSBzY29yZSArPSAxMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbkNyZWRpdENhcmREZWJ0ID09PSBcIlllc1wiICYmIGNhcmRDYXRlZ29yaWVzLmluY2x1ZGVzKFwiYmFsYW5jZVwiKSkgc2NvcmUgKz0gMTA7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluSG90ZWxDYXJkcyA9PT0gXCJZZXNcIiAmJiBjYXJkQ2F0ZWdvcmllcy5pbmNsdWRlcyhcImhvdGVsXCIpKSBzY29yZSArPSAxMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5BaXJsaW5lQ2FyZHMgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJhaXJsaW5lXCIpKSBzY29yZSArPSAxMDtcclxuXHJcbiAgICBpZiAocHJlZmVyZW5jZXMucHJlZmVycmVkQWlybGluZSkge1xyXG4gICAgICBpZiAoY2FyZE5hbWUuaW5jbHVkZXMocHJlZmVyZW5jZXMucHJlZmVycmVkQWlybGluZS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgIHNjb3JlICs9IDUwMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5wcmVmZXJyZWRIb3RlbCkge1xyXG4gICAgICBpZiAoY2FyZE5hbWUuaW5jbHVkZXMocHJlZmVyZW5jZXMucHJlZmVycmVkSG90ZWwudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICBzY29yZSArPSAxMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5jdXJyZW50QmFua3MgJiYgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmZvckVhY2goYmFuayA9PiB7XHJcbiAgICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKGJhbmsudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgIHNjb3JlICs9IDEwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgLi4uY2FyZCwgc2NvcmUgfTsgLy8gUmV0dXJuIGNhcmQgd2l0aCB1cGRhdGVkIHNjb3JlXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHNvcnQgYW5kIHRpZXIgY2FyZHNcclxuZnVuY3Rpb24gc29ydEFuZFRpZXJDYXJkcyhjYXJkcykge1xyXG4gIGNvbnN0IHRpZXJzID0geyB0aWVyMDogW10sIHRpZXIxOiBbXSwgdGllcjI6IFtdLCB0aWVyMzogW10gfTtcclxuXHJcbiAgY2FyZHMuZm9yRWFjaChjYXJkID0+IHtcclxuICAgIGlmIChjYXJkLlRpZXIgPT09IFwiMFwiKSB0aWVycy50aWVyMC5wdXNoKGNhcmQpO1xyXG4gICAgZWxzZSBpZiAoY2FyZC5UaWVyID09PSBcIjFcIikgdGllcnMudGllcjEucHVzaChjYXJkKTtcclxuICAgIGVsc2UgaWYgKGNhcmQuVGllciA9PT0gXCIyXCIpIHRpZXJzLnRpZXIyLnB1c2goY2FyZCk7XHJcbiAgICBlbHNlIGlmIChjYXJkLlRpZXIgPT09IFwiM1wiKSB0aWVycy50aWVyMy5wdXNoKGNhcmQpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBTb3J0IGVhY2ggdGllciBieSB0aGUgdXBkYXRlZCBzY29yZVxyXG4gIGZvciAoY29uc3QgdGllciBpbiB0aWVycykge1xyXG4gICAgdGllcnNbdGllcl0uc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRpZXJzO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBzb3J0IGJ5IGJvdGggY2F0ZWdvcnkgYW5kIHRpZXIsIHJldHVybmluZyBvbmx5IHRoZSB0b3AgY2FyZFxyXG5mdW5jdGlvbiBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIHRpZXIpIHtcclxuICBjb25zdCBjYXJkc0luVGllciA9IHJlY29tbWVuZGVkQ2FyZHNbYHRpZXIke3RpZXJ9YF07XHJcblxyXG4gIGlmICghY2FyZHNJblRpZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGBObyBjYXJkcyBmb3VuZCBmb3IgdGllcjogJHt0aWVyfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBGaWx0ZXIgYW5kIG9yZ2FuaXplIGNhcmRzIGJ5IGNhdGVnb3J5XHJcbiAgY29uc3Qgc29ydGVkQnlDYXRlZ29yeSA9IHt9O1xyXG5cclxuICBjYXJkc0luVGllci5mb3JFYWNoKGNhcmQgPT4ge1xyXG4gICAgY29uc3QgY2FyZENhdGVnb3J5ID0gY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIFBlcmZvcm0gcGFydGlhbCBtYXRjaCBmb3IgY2F0ZWdvcnlcclxuICAgIGlmIChjYXJkQ2F0ZWdvcnkuaW5jbHVkZXMoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgaWYgKCFzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0pIHtcclxuICAgICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0ucHVzaChjYXJkKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKE9iamVjdC5rZXlzKHNvcnRlZEJ5Q2F0ZWdvcnkpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coYE5vIGNhcmRzIGZvdW5kIGZvciBjYXRlZ29yaWVzIGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGxldCB0b3BDYXJkID0gbnVsbDtcclxuXHJcbiAgLy8gRmluZCB0aGUgdG9wIGNhcmQgYnkgc2NvcmUgYWNyb3NzIGFsbCBtYXRjaGluZyBjYXRlZ29yaWVzXHJcbiAgZm9yIChjb25zdCBtYXRjaGVkQ2F0ZWdvcnkgaW4gc29ydGVkQnlDYXRlZ29yeSkge1xyXG4gICAgY29uc3Qgc29ydGVkQ2FyZHMgPSBbLi4uc29ydGVkQnlDYXRlZ29yeVttYXRjaGVkQ2F0ZWdvcnldXS5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcblxyXG4gICAgLy8gVGFrZSB0aGUgZmlyc3QgY2FyZCAoaGlnaGVzdCBzY29yZSkgaWYgdGhlcmUgaXMgbm8gdG9wQ2FyZCB5ZXQgb3IgaWYgdGhlIGN1cnJlbnQgY2FyZCBoYXMgYSBoaWdoZXIgc2NvcmVcclxuICAgIGlmICghdG9wQ2FyZCB8fCBzb3J0ZWRDYXJkc1swXS5zY29yZSA+IHRvcENhcmQuc2NvcmUpIHtcclxuICAgICAgdG9wQ2FyZCA9IHNvcnRlZENhcmRzWzBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCF0b3BDYXJkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTm8gdG9wIGNhcmQgZm91bmQgZm9yIGNhdGVnb3J5IGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9IGFuZCB0aWVyOiAke3RpZXJ9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0b3BDYXJkO1xyXG59XHJcblxyXG4vLyBNYWluIGZ1bmN0aW9uIHRvIGdldCByZWNvbW1lbmRlZCBjYXJkc1xyXG5mdW5jdGlvbiBnZXRSZWNvbW1lbmRlZENhcmRzKHVzZXJQcmVmZXJlbmNlcykge1xyXG4gIGNvbnN0IHsgZmlsdGVyZWRDYXJkcywgcG9vciB9ID0gZmlsdGVyQnlDcmVkaXRTY29yZShjYXJkcywgdXNlclByZWZlcmVuY2VzLmNyZWRpdFNjb3JlKTtcclxuICBjb25zdCBhZGp1c3RlZENhcmRzID0gYXBwbHlQcmVmZXJlbmNlcyhmaWx0ZXJlZENhcmRzLCB1c2VyUHJlZmVyZW5jZXMpO1xyXG4gIGNvbnN0IHNjb3JlZENhcmRzID0gY2FsY3VsYXRlU2NvcmVzKGFkanVzdGVkQ2FyZHMsIHVzZXJQcmVmZXJlbmNlcyk7XHJcbiAgY29uc3Qgc29ydGVkQ2FyZHMgPSBzb3J0QW5kVGllckNhcmRzKHNjb3JlZENhcmRzKTtcclxuICByZXR1cm4geyBzb3J0ZWRDYXJkcywgcG9vciB9OyAvLyBSZXR1cm4gcG9vciBmbGFnIGFzIHdlbGxcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGZpbmFsIHJlY29tbWVuZGVkIGNhcmRzXHJcbmZ1bmN0aW9uIGZpbmFsQ2FyZHModXNlcklucHV0KSB7XHJcbiAgY29uc3QgeyBzb3J0ZWRDYXJkczogcmVjb21tZW5kZWRDYXJkcywgcG9vciB9ID0gZ2V0UmVjb21tZW5kZWRDYXJkcyh1c2VySW5wdXQpO1xyXG4gIGNvbnN0IHJldHVybkNhcmQgPSBbXTtcclxuICBjb25zdCBjYXJkQ2F0ZWdvcmllcyA9IHVzZXJJbnB1dC50b3BDYXRlZ29yaWVzLm1hcChjYXRlZ29yeSA9PiBjYXRlZ29yeS50b0xvd2VyQ2FzZSgpKTtcclxuICBsZXQgaW5kZXggPSAxO1xyXG5cclxuICBpZiAocG9vcikge1xyXG4gICAgaW5kZXgtLTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZENhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gY2FyZENhdGVnb3JpZXNbaV07XHJcbiAgICBjb25zdCBjYXJkMSA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBjYXRlZ29yeSwgMCArIGluZGV4KTtcclxuICAgIGNvbnN0IGNhcmQyID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIGNhdGVnb3J5LCAxICsgaW5kZXgpO1xyXG4gICAgY29uc3QgY2FyZDMgPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIDIgKyBpbmRleCk7XHJcbiAgICBpZiAoY2FyZDEgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDIgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDMgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhcmRNID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiQ2F0Y2ggQWxsXCIsIDEpO1xyXG4gIGlmIChjYXJkTSkgcmV0dXJuQ2FyZC5wdXNoKGNhcmRNKTtcclxuXHJcbiAgaWYgKHVzZXJJbnB1dC5pbnRlcmVzdGVkSW5Ib3RlbENhcmRzID09PSBcInllc1wiKSB7XHJcbiAgICBjb25zdCBjYXJkID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiSG90ZWxcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1lbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuICBpZiAodXNlcklucHV0LmludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyA9PT0gXCJ5ZXNcIikge1xyXG4gICAgY29uc3QgY2FyZCA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBcIkFpcmxpbmVcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1cclxuICBlbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldHVybkNhcmQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBmaW5hbENhcmRzIH07Il0sIm5hbWVzIjpbImNhcmRzIiwicmVxdWlyZSIsImZpbHRlckJ5Q3JlZGl0U2NvcmUiLCJjcmVkaXRTY29yZSIsImFsbG93ZWRUaWVycyIsIm1hdGNoZWRDcmVkaXRMZXZlbCIsInBvb3IiLCJpbmNsdWRlcyIsImZpbHRlcmVkQ2FyZHMiLCJmaWx0ZXIiLCJjYXJkIiwiVGllciIsImFwcGx5UHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsImlzU3R1ZGVudCIsIk5hbWUiLCJ0b0xvd2VyQ2FzZSIsImlzQnVzaW5lc3NPd25lciIsIkNhdGVnb3J5IiwiaW50ZXJlc3RlZEluSG90ZWxDYXJkcyIsImludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyIsImNhbGN1bGF0ZVNjb3JlcyIsIm1hcCIsInNjb3JlIiwiU2NvcmUiLCJjYXJkQ2F0ZWdvcmllcyIsInNwbGl0IiwiY2FyZE5hbWUiLCJ0b3BDYXRlZ29yaWVzIiwibGVuZ3RoIiwibWF0Y2hlc1RvcENhdGVnb3J5Iiwic29tZSIsImNhdGVnb3J5IiwiY2FyZENhdGVnb3J5IiwidHJpbSIsImluQ3JlZGl0Q2FyZERlYnQiLCJwcmVmZXJyZWRBaXJsaW5lIiwicHJlZmVycmVkSG90ZWwiLCJjdXJyZW50QmFua3MiLCJmb3JFYWNoIiwiYmFuayIsInNvcnRBbmRUaWVyQ2FyZHMiLCJ0aWVycyIsInRpZXIwIiwidGllcjEiLCJ0aWVyMiIsInRpZXIzIiwicHVzaCIsInRpZXIiLCJzb3J0IiwiYSIsImIiLCJzb3J0QnlDYXRlZ29yeUFuZFRpZXIiLCJyZWNvbW1lbmRlZENhcmRzIiwiY2FyZHNJblRpZXIiLCJjb25zb2xlIiwibG9nIiwic29ydGVkQnlDYXRlZ29yeSIsIk9iamVjdCIsImtleXMiLCJ0b3BDYXJkIiwibWF0Y2hlZENhdGVnb3J5Iiwic29ydGVkQ2FyZHMiLCJnZXRSZWNvbW1lbmRlZENhcmRzIiwidXNlclByZWZlcmVuY2VzIiwiYWRqdXN0ZWRDYXJkcyIsInNjb3JlZENhcmRzIiwiZmluYWxDYXJkcyIsInVzZXJJbnB1dCIsInJldHVybkNhcmQiLCJpbmRleCIsImkiLCJjYXJkMSIsImNhcmQyIiwiY2FyZDMiLCJjYXJkTSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/complete/algorithm.js\n"));

/***/ })

});