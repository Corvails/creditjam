"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/complete/page",{

/***/ "(app-pages-browser)/./src/app/complete/algorithm.js":
/*!***************************************!*\
  !*** ./src/app/complete/algorithm.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nconst cards = __webpack_require__(/*! ./finalcreditcard.json */ \"(app-pages-browser)/./src/app/complete/finalcreditcard.json\");\n// Function to filter by credit score\nfunction filterByCreditScore(cards, creditScore) {\n    const allowedTiers = {\n        \"Poor\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Fair\": [\n            \"0\",\n            \"1\",\n            \"2\"\n        ],\n        \"Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Very Good\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ],\n        \"Excellent\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    };\n    let matchedCreditLevel = null;\n    let poor = false;\n    if (creditScore.includes(\"Poor\")) {\n        matchedCreditLevel = \"Poor\";\n        poor = true;\n    } else if (creditScore.includes(\"Fair\")) {\n        matchedCreditLevel = \"Fair\";\n        poor = true;\n    } else if (creditScore.includes(\"Good\")) {\n        matchedCreditLevel = \"Good\";\n    } else if (creditScore.includes(\"Very good\")) {\n        matchedCreditLevel = \"Very Good\";\n    } else if (creditScore.includes(\"Excellent\")) {\n        matchedCreditLevel = \"Excellent\";\n    }\n    // Filter cards by checking if the card's tier is allowed for the user's credit score\n    const filteredCards = cards.filter((card)=>allowedTiers[matchedCreditLevel].includes(card.Tier));\n    return {\n        filteredCards,\n        poor\n    };\n}\n// Function to apply user preferences (nuking)\nfunction applyPreferences(cards, preferences) {\n    return cards.filter((card)=>{\n        if (preferences.isStudent === \"No\" && card.Name.toLowerCase().includes(\"student\")) {\n            return false;\n        }\n        if (preferences.isBusinessOwner === \"No\" && card.Category.toLowerCase().includes(\"business\")) {\n            return false;\n        }\n        if (preferences.interestedInHotelCards === \"No\" && card.Category.toLowerCase().includes(\"hotel\")) {\n            return false;\n        }\n        if (preferences.interestedInAirlineCards === \"No\" && card.Category.toLowerCase().includes(\"airline\")) {\n            return false;\n        }\n        return true;\n    });\n}\nfunction calculateScores(cards, preferences) {\n    return cards.map((card)=>{\n        let score = +card.Score || 50;\n        // Split categories\n        const cardCategories = card.Category ? card.Category.toLowerCase().split(\"/\") : [];\n        const cardName = card.Name ? card.Name.toLowerCase() : \"\";\n        // Apply scoring rules\n        if (preferences.topCategories && preferences.topCategories.length > 0) {\n            // Check if any topCategory matches any of the card's categories\n            const matchesTopCategory = preferences.topCategories.some((category)=>cardCategories.some((cardCategory)=>cardCategory.trim() === category.toLowerCase()));\n            if (matchesTopCategory) {\n                score += 15; // Add 15 points if card's category matches any topCategory\n            }\n        }\n        if (preferences.isStudent === \"Yes\" && cardName.includes(\"student\")) score += 15;\n        if (preferences.isBusinessOwner === \"Yes\" && cardCategories.includes(\"business\")) score += 10;\n        if (preferences.inCreditCardDebt === \"Yes\" && cardCategories.includes(\"balance\")) score += 10;\n        if (preferences.interestedInHotelCards === \"Yes\" && cardCategories.includes(\"hotel\")) score += 500;\n        if (preferences.interestedInAirlineCards === \"Yes\" && cardCategories.includes(\"airline\")) score += 500;\n        if (preferences.preferredAirline) {\n            if (cardName.includes(preferences.preferredAirline.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.preferredHotels) {\n            if (cardName.includes(preferences.preferredAirline.toLowerCase())) {\n                score += 10;\n            }\n        }\n        if (preferences.currentBanks && preferences.currentBanks.length > 0) {\n            preferences.currentBanks.forEach((bank)=>{\n                if (cardName.includes(bank.toLowerCase())) {\n                    score += 10;\n                }\n            });\n        }\n        return {\n            ...card,\n            score\n        }; // Return card with updated score\n    });\n}\n// Function to sort and tier cards\nfunction sortAndTierCards(cards) {\n    const tiers = {\n        tier0: [],\n        tier1: [],\n        tier2: [],\n        tier3: []\n    };\n    cards.forEach((card)=>{\n        if (card.Tier === \"0\") tiers.tier0.push(card);\n        else if (card.Tier === \"1\") tiers.tier1.push(card);\n        else if (card.Tier === \"2\") tiers.tier2.push(card);\n        else if (card.Tier === \"3\") tiers.tier3.push(card);\n    });\n    // Sort each tier by the updated score\n    for(const tier in tiers){\n        tiers[tier].sort((a, b)=>b.score - a.score);\n    }\n    return tiers;\n}\n// Function to sort by both category and tier, returning only the top card\nfunction sortByCategoryAndTier(recommendedCards, category, tier) {\n    const cardsInTier = recommendedCards[\"tier\".concat(tier)];\n    if (!cardsInTier) {\n        console.log(\"No cards found for tier: \".concat(tier));\n        return null;\n    }\n    // Filter and organize cards by category\n    const sortedByCategory = {};\n    cardsInTier.forEach((card)=>{\n        const cardCategory = card.Category.toLowerCase();\n        // Perform partial match for category\n        if (cardCategory.includes(category.toLowerCase())) {\n            if (!sortedByCategory[cardCategory]) {\n                sortedByCategory[cardCategory] = [];\n            }\n            sortedByCategory[cardCategory].push(card);\n        }\n    });\n    if (Object.keys(sortedByCategory).length === 0) {\n        console.log(\"No cards found for categories containing: \".concat(category));\n        return null;\n    }\n    let topCard = null;\n    // Find the top card by score across all matching categories\n    for(const matchedCategory in sortedByCategory){\n        const sortedCards = [\n            ...sortedByCategory[matchedCategory]\n        ].sort((a, b)=>b.score - a.score);\n        // Take the first card (highest score) if there is no topCard yet or if the current card has a higher score\n        if (!topCard || sortedCards[0].score > topCard.score) {\n            topCard = sortedCards[0];\n        }\n    }\n    if (!topCard) {\n        console.log(\"No top card found for category containing: \".concat(category, \" and tier: \").concat(tier));\n        return null;\n    }\n    return topCard;\n}\n// Main function to get recommended cards\nfunction getRecommendedCards(userPreferences) {\n    const { filteredCards, poor } = filterByCreditScore(cards, userPreferences.creditScore);\n    const adjustedCards = applyPreferences(filteredCards, userPreferences);\n    const scoredCards = calculateScores(adjustedCards, userPreferences);\n    const sortedCards = sortAndTierCards(scoredCards);\n    return {\n        sortedCards,\n        poor\n    }; // Return poor flag as well\n}\n// Function to get final recommended cards\nfunction finalCards(userInput) {\n    const { sortedCards: recommendedCards, poor } = getRecommendedCards(userInput);\n    const returnCard = [];\n    const cardCategories = userInput.topCategories.map((category)=>category.toLowerCase());\n    let index = 1;\n    if (poor) {\n        index--;\n    }\n    for(let i = 0; i < cardCategories.length; i++){\n        const category = cardCategories[i];\n        const card1 = sortByCategoryAndTier(recommendedCards, category, 0 + index);\n        const card2 = sortByCategoryAndTier(recommendedCards, category, 1 + index);\n        const card3 = sortByCategoryAndTier(recommendedCards, category, 2 + index);\n        if (card1 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card1);\n        }\n        if (card2 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card2);\n        }\n        if (card3 === null) {\n            returnCard.push(\"N/A\");\n        } else {\n            returnCard.push(card3);\n        }\n    }\n    const cardM = sortByCategoryAndTier(recommendedCards, \"Catch All\", 1);\n    if (cardM) returnCard.push(cardM);\n    if (userInput.interestedInHotelCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Hotel\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    if (userInput.interestedInAirlineCards === \"yes\") {\n        const card = sortByCategoryAndTier(recommendedCards, \"Airline\", 1);\n        if (card) returnCard.push(card);\n    } else {\n        returnCard.push(\"N/A\");\n    }\n    return returnCard;\n}\nmodule.exports = {\n    finalCards\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcGxldGUvYWxnb3JpdGhtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQywyRkFBd0I7QUFFOUMscUNBQXFDO0FBQ3JDLFNBQVNDLG9CQUFvQkYsS0FBSyxFQUFFRyxXQUFXO0lBQzdDLE1BQU1DLGVBQWU7UUFDbkIsUUFBUTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQ3ZCLFFBQVE7WUFBQztZQUFLO1lBQUs7U0FBSTtRQUN2QixRQUFRO1lBQUM7WUFBSztZQUFLO1NBQUk7UUFDdkIsYUFBYTtZQUFDO1lBQUs7WUFBSztTQUFJO1FBQzVCLGFBQWE7WUFBQztZQUFLO1lBQUs7U0FBSTtJQUM5QjtJQUVBLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxPQUFPO0lBRVgsSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDaENGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtRQUNyQkMsT0FBTztJQUNULE9BQU8sSUFBSUgsWUFBWUksUUFBUSxDQUFDLFNBQVM7UUFDdkNGLHFCQUFxQjtJQUN2QixPQUFPLElBQUlGLFlBQVlJLFFBQVEsQ0FBQyxjQUFjO1FBQzVDRixxQkFBcUI7SUFDdkIsT0FBTyxJQUFJRixZQUFZSSxRQUFRLENBQUMsY0FBYztRQUM1Q0YscUJBQXFCO0lBQ3ZCO0lBRUEscUZBQXFGO0lBQ3JGLE1BQU1HLGdCQUFnQlIsTUFBTVMsTUFBTSxDQUFDQyxDQUFBQSxPQUNqQ04sWUFBWSxDQUFDQyxtQkFBbUIsQ0FBQ0UsUUFBUSxDQUFDRyxLQUFLQyxJQUFJO0lBR3JELE9BQU87UUFBRUg7UUFBZUY7SUFBSztBQUMvQjtBQUVBLDhDQUE4QztBQUM5QyxTQUFTTSxpQkFBaUJaLEtBQUssRUFBRWEsV0FBVztJQUMxQyxPQUFPYixNQUFNUyxNQUFNLENBQUNDLENBQUFBO1FBQ2xCLElB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QUs7UUFDSDJELFdBQVd0QixJQUFJLENBQUM7SUFDbEI7SUFDQSxJQUFJcUIsVUFBVWhELHdCQUF3QixLQUFLLE9BQU87UUFDaEQsTUFBTVYsT0FBTzBDLHNCQUFzQkMsa0JBQWtCLFdBQVc7UUFDaEUsSUFBSTNDLE1BQU0yRCxXQUFXdEIsSUFBSSxDQUFDckM7SUFDNUIsT0FDSTtRQUNGMkQsV0FBV3RCLElBQUksQ0FBQztJQUNsQjtJQUVBLE9BQU9zQjtBQUNUO0FBRUFPLE9BQU9DLE9BQU8sR0FBRztJQUFFVjtBQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvY29tcGxldGUvYWxnb3JpdGhtLmpzPzFhNzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY2FyZHMgPSByZXF1aXJlKFwiLi9maW5hbGNyZWRpdGNhcmQuanNvblwiKTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGZpbHRlciBieSBjcmVkaXQgc2NvcmVcclxuZnVuY3Rpb24gZmlsdGVyQnlDcmVkaXRTY29yZShjYXJkcywgY3JlZGl0U2NvcmUpIHtcclxuICBjb25zdCBhbGxvd2VkVGllcnMgPSB7XHJcbiAgICBcIlBvb3JcIjogW1wiMFwiLCBcIjFcIiwgXCIyXCJdLFxyXG4gICAgXCJGYWlyXCI6IFtcIjBcIiwgXCIxXCIsIFwiMlwiXSxcclxuICAgIFwiR29vZFwiOiBbXCIxXCIsIFwiMlwiLCBcIjNcIl0sXHJcbiAgICBcIlZlcnkgR29vZFwiOiBbXCIxXCIsIFwiMlwiLCBcIjNcIl0sXHJcbiAgICBcIkV4Y2VsbGVudFwiOiBbXCIxXCIsIFwiMlwiLCBcIjNcIl0sXHJcbiAgfTtcclxuXHJcbiAgbGV0IG1hdGNoZWRDcmVkaXRMZXZlbCA9IG51bGw7XHJcbiAgbGV0IHBvb3IgPSBmYWxzZTtcclxuXHJcbiAgaWYgKGNyZWRpdFNjb3JlLmluY2x1ZGVzKFwiUG9vclwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJQb29yXCI7XHJcbiAgICBwb29yID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGNyZWRpdFNjb3JlLmluY2x1ZGVzKFwiRmFpclwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJGYWlyXCI7XHJcbiAgICBwb29yID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGNyZWRpdFNjb3JlLmluY2x1ZGVzKFwiR29vZFwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJHb29kXCI7XHJcbiAgfSBlbHNlIGlmIChjcmVkaXRTY29yZS5pbmNsdWRlcyhcIlZlcnkgZ29vZFwiKSkge1xyXG4gICAgbWF0Y2hlZENyZWRpdExldmVsID0gXCJWZXJ5IEdvb2RcIjtcclxuICB9IGVsc2UgaWYgKGNyZWRpdFNjb3JlLmluY2x1ZGVzKFwiRXhjZWxsZW50XCIpKSB7XHJcbiAgICBtYXRjaGVkQ3JlZGl0TGV2ZWwgPSBcIkV4Y2VsbGVudFwiO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlsdGVyIGNhcmRzIGJ5IGNoZWNraW5nIGlmIHRoZSBjYXJkJ3MgdGllciBpcyBhbGxvd2VkIGZvciB0aGUgdXNlcidzIGNyZWRpdCBzY29yZVxyXG4gIGNvbnN0IGZpbHRlcmVkQ2FyZHMgPSBjYXJkcy5maWx0ZXIoY2FyZCA9PlxyXG4gICAgYWxsb3dlZFRpZXJzW21hdGNoZWRDcmVkaXRMZXZlbF0uaW5jbHVkZXMoY2FyZC5UaWVyKVxyXG4gICk7XHJcblxyXG4gIHJldHVybiB7IGZpbHRlcmVkQ2FyZHMsIHBvb3IgfTtcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gYXBwbHkgdXNlciBwcmVmZXJlbmNlcyAobnVraW5nKVxyXG5mdW5jdGlvbiBhcHBseVByZWZlcmVuY2VzKGNhcmRzLCBwcmVmZXJlbmNlcykge1xyXG4gIHJldHVybiBjYXJkcy5maWx0ZXIoY2FyZCA9PiB7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaXNTdHVkZW50ID09PSBcIk5vXCIgJiYgY2FyZC5OYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzdHVkZW50XCIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChwcmVmZXJlbmNlcy5pc0J1c2luZXNzT3duZXIgPT09IFwiTm9cIiAmJiBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJidXNpbmVzc1wiKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaW50ZXJlc3RlZEluSG90ZWxDYXJkcyA9PT0gXCJOb1wiICYmIGNhcmQuQ2F0ZWdvcnkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImhvdGVsXCIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5BaXJsaW5lQ2FyZHMgPT09IFwiTm9cIiAmJiBjYXJkLkNhdGVnb3J5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJhaXJsaW5lXCIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTY29yZXMoY2FyZHMsIHByZWZlcmVuY2VzKSB7XHJcbiAgcmV0dXJuIGNhcmRzLm1hcChjYXJkID0+IHtcclxuICAgIGxldCBzY29yZSA9ICtjYXJkLlNjb3JlIHx8IDUwO1xyXG5cclxuICAgIC8vIFNwbGl0IGNhdGVnb3JpZXNcclxuICAgIGNvbnN0IGNhcmRDYXRlZ29yaWVzID0gY2FyZC5DYXRlZ29yeSA/IGNhcmQuQ2F0ZWdvcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpIDogW107XHJcbiAgICBjb25zdCBjYXJkTmFtZSA9IGNhcmQuTmFtZSA/IGNhcmQuTmFtZS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcclxuXHJcbiAgICAvLyBBcHBseSBzY29yaW5nIHJ1bGVzXHJcbiAgICBpZiAocHJlZmVyZW5jZXMudG9wQ2F0ZWdvcmllcyAmJiBwcmVmZXJlbmNlcy50b3BDYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgYW55IHRvcENhdGVnb3J5IG1hdGNoZXMgYW55IG9mIHRoZSBjYXJkJ3MgY2F0ZWdvcmllc1xyXG4gICAgICBjb25zdCBtYXRjaGVzVG9wQ2F0ZWdvcnkgPSBwcmVmZXJlbmNlcy50b3BDYXRlZ29yaWVzLnNvbWUoY2F0ZWdvcnkgPT5cclxuICAgICAgICBjYXJkQ2F0ZWdvcmllcy5zb21lKGNhcmRDYXRlZ29yeSA9PiBjYXJkQ2F0ZWdvcnkudHJpbSgpID09PSBjYXRlZ29yeS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICApO1xyXG4gICAgICBpZiAobWF0Y2hlc1RvcENhdGVnb3J5KSB7XHJcbiAgICAgICAgc2NvcmUgKz0gMTU7IC8vIEFkZCAxNSBwb2ludHMgaWYgY2FyZCdzIGNhdGVnb3J5IG1hdGNoZXMgYW55IHRvcENhdGVnb3J5XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaXNTdHVkZW50ID09PSBcIlllc1wiICYmIGNhcmROYW1lLmluY2x1ZGVzKFwic3R1ZGVudFwiKSkgc2NvcmUgKz0gMTU7XHJcbiAgICBpZiAocHJlZmVyZW5jZXMuaXNCdXNpbmVzc093bmVyID09PSBcIlllc1wiICYmIGNhcmRDYXRlZ29yaWVzLmluY2x1ZGVzKFwiYnVzaW5lc3NcIikpIHNjb3JlICs9IDEwO1xyXG4gICAgaWYgKHByZWZlcmVuY2VzLmluQ3JlZGl0Q2FyZERlYnQgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJiYWxhbmNlXCIpKSBzY29yZSArPSAxMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5Ib3RlbENhcmRzID09PSBcIlllc1wiICYmIGNhcmRDYXRlZ29yaWVzLmluY2x1ZGVzKFwiaG90ZWxcIikpIHNjb3JlICs9IDUwMDtcclxuICAgIGlmIChwcmVmZXJlbmNlcy5pbnRlcmVzdGVkSW5BaXJsaW5lQ2FyZHMgPT09IFwiWWVzXCIgJiYgY2FyZENhdGVnb3JpZXMuaW5jbHVkZXMoXCJhaXJsaW5lXCIpKSBzY29yZSArPSA1MDA7XHJcblxyXG4gICAgaWYgKHByZWZlcmVuY2VzLnByZWZlcnJlZEFpcmxpbmUpIHtcclxuICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKHByZWZlcmVuY2VzLnByZWZlcnJlZEFpcmxpbmUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICBzY29yZSArPSAxMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5wcmVmZXJyZWRIb3RlbHMpIHtcclxuICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKHByZWZlcmVuY2VzLnByZWZlcnJlZEFpcmxpbmUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICBzY29yZSArPSAxMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmVmZXJlbmNlcy5jdXJyZW50QmFua3MgJiYgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcHJlZmVyZW5jZXMuY3VycmVudEJhbmtzLmZvckVhY2goYmFuayA9PiB7XHJcbiAgICAgICAgaWYgKGNhcmROYW1lLmluY2x1ZGVzKGJhbmsudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgIHNjb3JlICs9IDEwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgLi4uY2FyZCwgc2NvcmUgfTsgLy8gUmV0dXJuIGNhcmQgd2l0aCB1cGRhdGVkIHNjb3JlXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHNvcnQgYW5kIHRpZXIgY2FyZHNcclxuZnVuY3Rpb24gc29ydEFuZFRpZXJDYXJkcyhjYXJkcykge1xyXG4gIGNvbnN0IHRpZXJzID0geyB0aWVyMDogW10sIHRpZXIxOiBbXSwgdGllcjI6IFtdLCB0aWVyMzogW10gfTtcclxuXHJcbiAgY2FyZHMuZm9yRWFjaChjYXJkID0+IHtcclxuICAgIGlmIChjYXJkLlRpZXIgPT09IFwiMFwiKSB0aWVycy50aWVyMC5wdXNoKGNhcmQpO1xyXG4gICAgZWxzZSBpZiAoY2FyZC5UaWVyID09PSBcIjFcIikgdGllcnMudGllcjEucHVzaChjYXJkKTtcclxuICAgIGVsc2UgaWYgKGNhcmQuVGllciA9PT0gXCIyXCIpIHRpZXJzLnRpZXIyLnB1c2goY2FyZCk7XHJcbiAgICBlbHNlIGlmIChjYXJkLlRpZXIgPT09IFwiM1wiKSB0aWVycy50aWVyMy5wdXNoKGNhcmQpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBTb3J0IGVhY2ggdGllciBieSB0aGUgdXBkYXRlZCBzY29yZVxyXG4gIGZvciAoY29uc3QgdGllciBpbiB0aWVycykge1xyXG4gICAgdGllcnNbdGllcl0uc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRpZXJzO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBzb3J0IGJ5IGJvdGggY2F0ZWdvcnkgYW5kIHRpZXIsIHJldHVybmluZyBvbmx5IHRoZSB0b3AgY2FyZFxyXG5mdW5jdGlvbiBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIHRpZXIpIHtcclxuICBjb25zdCBjYXJkc0luVGllciA9IHJlY29tbWVuZGVkQ2FyZHNbYHRpZXIke3RpZXJ9YF07XHJcblxyXG4gIGlmICghY2FyZHNJblRpZXIpIHtcclxuICAgIGNvbnNvbGUubG9nKGBObyBjYXJkcyBmb3VuZCBmb3IgdGllcjogJHt0aWVyfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBGaWx0ZXIgYW5kIG9yZ2FuaXplIGNhcmRzIGJ5IGNhdGVnb3J5XHJcbiAgY29uc3Qgc29ydGVkQnlDYXRlZ29yeSA9IHt9O1xyXG5cclxuICBjYXJkc0luVGllci5mb3JFYWNoKGNhcmQgPT4ge1xyXG4gICAgY29uc3QgY2FyZENhdGVnb3J5ID0gY2FyZC5DYXRlZ29yeS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIFBlcmZvcm0gcGFydGlhbCBtYXRjaCBmb3IgY2F0ZWdvcnlcclxuICAgIGlmIChjYXJkQ2F0ZWdvcnkuaW5jbHVkZXMoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgaWYgKCFzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0pIHtcclxuICAgICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBzb3J0ZWRCeUNhdGVnb3J5W2NhcmRDYXRlZ29yeV0ucHVzaChjYXJkKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKE9iamVjdC5rZXlzKHNvcnRlZEJ5Q2F0ZWdvcnkpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coYE5vIGNhcmRzIGZvdW5kIGZvciBjYXRlZ29yaWVzIGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGxldCB0b3BDYXJkID0gbnVsbDtcclxuXHJcbiAgLy8gRmluZCB0aGUgdG9wIGNhcmQgYnkgc2NvcmUgYWNyb3NzIGFsbCBtYXRjaGluZyBjYXRlZ29yaWVzXHJcbiAgZm9yIChjb25zdCBtYXRjaGVkQ2F0ZWdvcnkgaW4gc29ydGVkQnlDYXRlZ29yeSkge1xyXG4gICAgY29uc3Qgc29ydGVkQ2FyZHMgPSBbLi4uc29ydGVkQnlDYXRlZ29yeVttYXRjaGVkQ2F0ZWdvcnldXS5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XHJcblxyXG4gICAgLy8gVGFrZSB0aGUgZmlyc3QgY2FyZCAoaGlnaGVzdCBzY29yZSkgaWYgdGhlcmUgaXMgbm8gdG9wQ2FyZCB5ZXQgb3IgaWYgdGhlIGN1cnJlbnQgY2FyZCBoYXMgYSBoaWdoZXIgc2NvcmVcclxuICAgIGlmICghdG9wQ2FyZCB8fCBzb3J0ZWRDYXJkc1swXS5zY29yZSA+IHRvcENhcmQuc2NvcmUpIHtcclxuICAgICAgdG9wQ2FyZCA9IHNvcnRlZENhcmRzWzBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCF0b3BDYXJkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgTm8gdG9wIGNhcmQgZm91bmQgZm9yIGNhdGVnb3J5IGNvbnRhaW5pbmc6ICR7Y2F0ZWdvcnl9IGFuZCB0aWVyOiAke3RpZXJ9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0b3BDYXJkO1xyXG59XHJcblxyXG4vLyBNYWluIGZ1bmN0aW9uIHRvIGdldCByZWNvbW1lbmRlZCBjYXJkc1xyXG5mdW5jdGlvbiBnZXRSZWNvbW1lbmRlZENhcmRzKHVzZXJQcmVmZXJlbmNlcykge1xyXG4gIGNvbnN0IHsgZmlsdGVyZWRDYXJkcywgcG9vciB9ID0gZmlsdGVyQnlDcmVkaXRTY29yZShjYXJkcywgdXNlclByZWZlcmVuY2VzLmNyZWRpdFNjb3JlKTtcclxuICBjb25zdCBhZGp1c3RlZENhcmRzID0gYXBwbHlQcmVmZXJlbmNlcyhmaWx0ZXJlZENhcmRzLCB1c2VyUHJlZmVyZW5jZXMpO1xyXG4gIGNvbnN0IHNjb3JlZENhcmRzID0gY2FsY3VsYXRlU2NvcmVzKGFkanVzdGVkQ2FyZHMsIHVzZXJQcmVmZXJlbmNlcyk7XHJcbiAgY29uc3Qgc29ydGVkQ2FyZHMgPSBzb3J0QW5kVGllckNhcmRzKHNjb3JlZENhcmRzKTtcclxuICByZXR1cm4geyBzb3J0ZWRDYXJkcywgcG9vciB9OyAvLyBSZXR1cm4gcG9vciBmbGFnIGFzIHdlbGxcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGZpbmFsIHJlY29tbWVuZGVkIGNhcmRzXHJcbmZ1bmN0aW9uIGZpbmFsQ2FyZHModXNlcklucHV0KSB7XHJcbiAgY29uc3QgeyBzb3J0ZWRDYXJkczogcmVjb21tZW5kZWRDYXJkcywgcG9vciB9ID0gZ2V0UmVjb21tZW5kZWRDYXJkcyh1c2VySW5wdXQpO1xyXG4gIGNvbnN0IHJldHVybkNhcmQgPSBbXTtcclxuICBjb25zdCBjYXJkQ2F0ZWdvcmllcyA9IHVzZXJJbnB1dC50b3BDYXRlZ29yaWVzLm1hcChjYXRlZ29yeSA9PiBjYXRlZ29yeS50b0xvd2VyQ2FzZSgpKTtcclxuICBsZXQgaW5kZXggPSAxO1xyXG5cclxuICBpZiAocG9vcikge1xyXG4gICAgaW5kZXgtLTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZENhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gY2FyZENhdGVnb3JpZXNbaV07XHJcbiAgICBjb25zdCBjYXJkMSA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBjYXRlZ29yeSwgMCArIGluZGV4KTtcclxuICAgIGNvbnN0IGNhcmQyID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIGNhdGVnb3J5LCAxICsgaW5kZXgpO1xyXG4gICAgY29uc3QgY2FyZDMgPSBzb3J0QnlDYXRlZ29yeUFuZFRpZXIocmVjb21tZW5kZWRDYXJkcywgY2F0ZWdvcnksIDIgKyBpbmRleCk7XHJcbiAgICBpZiAoY2FyZDEgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDIgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FyZDMgPT09IG51bGwpe1xyXG4gICAgICByZXR1cm5DYXJkLnB1c2goXCJOL0FcIik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgcmV0dXJuQ2FyZC5wdXNoKGNhcmQzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhcmRNID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiQ2F0Y2ggQWxsXCIsIDEpO1xyXG4gIGlmIChjYXJkTSkgcmV0dXJuQ2FyZC5wdXNoKGNhcmRNKTtcclxuXHJcbiAgaWYgKHVzZXJJbnB1dC5pbnRlcmVzdGVkSW5Ib3RlbENhcmRzID09PSBcInllc1wiKSB7XHJcbiAgICBjb25zdCBjYXJkID0gc29ydEJ5Q2F0ZWdvcnlBbmRUaWVyKHJlY29tbWVuZGVkQ2FyZHMsIFwiSG90ZWxcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1lbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuICBpZiAodXNlcklucHV0LmludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyA9PT0gXCJ5ZXNcIikge1xyXG4gICAgY29uc3QgY2FyZCA9IHNvcnRCeUNhdGVnb3J5QW5kVGllcihyZWNvbW1lbmRlZENhcmRzLCBcIkFpcmxpbmVcIiwgMSk7XHJcbiAgICBpZiAoY2FyZCkgcmV0dXJuQ2FyZC5wdXNoKGNhcmQpO1xyXG4gIH1cclxuICBlbHNle1xyXG4gICAgcmV0dXJuQ2FyZC5wdXNoKFwiTi9BXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldHVybkNhcmQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBmaW5hbENhcmRzIH07Il0sIm5hbWVzIjpbImNhcmRzIiwicmVxdWlyZSIsImZpbHRlckJ5Q3JlZGl0U2NvcmUiLCJjcmVkaXRTY29yZSIsImFsbG93ZWRUaWVycyIsIm1hdGNoZWRDcmVkaXRMZXZlbCIsInBvb3IiLCJpbmNsdWRlcyIsImZpbHRlcmVkQ2FyZHMiLCJmaWx0ZXIiLCJjYXJkIiwiVGllciIsImFwcGx5UHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsImlzU3R1ZGVudCIsIk5hbWUiLCJ0b0xvd2VyQ2FzZSIsImlzQnVzaW5lc3NPd25lciIsIkNhdGVnb3J5IiwiaW50ZXJlc3RlZEluSG90ZWxDYXJkcyIsImludGVyZXN0ZWRJbkFpcmxpbmVDYXJkcyIsImNhbGN1bGF0ZVNjb3JlcyIsIm1hcCIsInNjb3JlIiwiU2NvcmUiLCJjYXJkQ2F0ZWdvcmllcyIsInNwbGl0IiwiY2FyZE5hbWUiLCJ0b3BDYXRlZ29yaWVzIiwibGVuZ3RoIiwibWF0Y2hlc1RvcENhdGVnb3J5Iiwic29tZSIsImNhdGVnb3J5IiwiY2FyZENhdGVnb3J5IiwidHJpbSIsImluQ3JlZGl0Q2FyZERlYnQiLCJwcmVmZXJyZWRBaXJsaW5lIiwicHJlZmVycmVkSG90ZWxzIiwiY3VycmVudEJhbmtzIiwiZm9yRWFjaCIsImJhbmsiLCJzb3J0QW5kVGllckNhcmRzIiwidGllcnMiLCJ0aWVyMCIsInRpZXIxIiwidGllcjIiLCJ0aWVyMyIsInB1c2giLCJ0aWVyIiwic29ydCIsImEiLCJiIiwic29ydEJ5Q2F0ZWdvcnlBbmRUaWVyIiwicmVjb21tZW5kZWRDYXJkcyIsImNhcmRzSW5UaWVyIiwiY29uc29sZSIsImxvZyIsInNvcnRlZEJ5Q2F0ZWdvcnkiLCJPYmplY3QiLCJrZXlzIiwidG9wQ2FyZCIsIm1hdGNoZWRDYXRlZ29yeSIsInNvcnRlZENhcmRzIiwiZ2V0UmVjb21tZW5kZWRDYXJkcyIsInVzZXJQcmVmZXJlbmNlcyIsImFkanVzdGVkQ2FyZHMiLCJzY29yZWRDYXJkcyIsImZpbmFsQ2FyZHMiLCJ1c2VySW5wdXQiLCJyZXR1cm5DYXJkIiwiaW5kZXgiLCJpIiwiY2FyZDEiLCJjYXJkMiIsImNhcmQzIiwiY2FyZE0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/complete/algorithm.js\n"));

/***/ })

});